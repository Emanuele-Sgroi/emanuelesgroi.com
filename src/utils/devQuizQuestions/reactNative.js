/**
 * NOTE: All question sets here (and their Q&A pairs) were generated by AI
 * to help with knowledge retention across a variety of technical topics.
 *
 * This File Contains the questions used in Dev Quiz.
 * It holds arrays of question objects, each representing a specific technical area.
 *
 * Each question object has the following structure:
 * - `id`: A unique identifier for the question.
 * - `topic`: The subject or category of the question (e.g., React, JavaScript, Node.js).
 * - `question`: The text of the question being asked.
 * - `language`: (Optional) A string indicating the programming language for code-related questions.
 * - `code`: (Optional) A boolean indicating if the question involves code.
 * - `options`: An array of possible answers, each with a `text` property and an optional `code` property.
 * - `answer`: The correct answer for the question.
 * - `explanation`: An explanation of why the answer is correct, with optional code examples.
 *
 * Topic covered in this file:
 * - React Native (Mobile development with React)
 */

export const reactNativeQuestions = [
  // 1–3: REACT NATIVE BASICS
  {
    id: 1,
    topic: "React Native",
    question: "What is the purpose of React Native?",
    code: false,
    language: false,
    options: [
      {
        text: "To build cross-platform mobile apps using JavaScript",
        code: false,
      },
      { text: "To create backend servers", code: false },
      { text: "To optimize web apps for mobile devices", code: false },
      { text: "To manage mobile databases", code: false },
    ],
    answer: "To build cross-platform mobile apps using JavaScript",
    explanation: {
      text: "React Native lets you build native-like mobile apps for iOS and Android using JavaScript and React principles.",
      code: false,
    },
  },
  {
    id: 2,
    topic: "React Native",
    question:
      "How does React Native differ from React for the web in terms of rendering?",
    code: false,
    language: false,
    options: [
      {
        text: "React Native renders platform-native components instead of the browser DOM",
        code: false,
      },
      {
        text: "There is no difference; both render HTML elements",
        code: false,
      },
      {
        text: "React Native uses iframes to display content",
        code: false,
      },
      {
        text: "React Native can only render text-based components",
        code: false,
      },
    ],
    answer:
      "React Native renders platform-native components instead of the browser DOM",
    explanation: {
      text: "React Native uses native widgets (e.g., UIView on iOS, View on Android) rather than HTML divs and spans.",
      code: false,
    },
  },
  {
    id: 3,
    topic: "React Native",
    question: "What is Expo in the React Native ecosystem?",
    code: false,
    language: false,
    options: [
      {
        text: "A toolchain that simplifies React Native development with managed workflows",
        code: false,
      },
      {
        text: "A library for building backend APIs",
        code: false,
      },
      {
        text: "A component library for advanced animations",
        code: false,
      },
      {
        text: "An alternative language that compiles to React Native",
        code: false,
      },
    ],
    answer:
      "A toolchain that simplifies React Native development with managed workflows",
    explanation: {
      text: "Expo provides a set of services, an SDK, and a CLI to help quickly start, build, and deploy React Native apps without touching native code (unless you choose to eject).",
      code: false,
    },
  },

  // 4–6: COMPONENTS & PROPS
  {
    id: 4,
    topic: "React Native",
    question:
      "Which React Native core component is used to render text on the screen?",
    code: false,
    language: false,
    options: [
      { text: "Text", code: false },
      { text: "Label", code: false },
      { text: "View", code: false },
      { text: "Span", code: false },
    ],
    answer: "Text",
    explanation: {
      text: "Unlike React for the web (which uses <div> and <span>), React Native has <View> and <Text> for structure and textual content, respectively.",
      code: false,
    },
  },
  {
    id: 5,
    topic: "React Native",
    question:
      "What is the correct way to pass props to a custom React Native component?",
    code: false,
    language: false,
    options: [
      {
        text: "<MyComponent myProp='hello' />",
        code: false,
      },
      {
        text: "<MyComponent props={{ myProp: 'hello' }} />",
        code: false,
      },
      {
        text: "<MyComponent :myProp='hello' />",
        code: false,
      },
      {
        text: "<MyComponent myProp={{ hello: true }} />",
        code: false,
      },
    ],
    answer: "<MyComponent myProp='hello' />",
    explanation: {
      text: "Props are passed the same way as in React for web: by adding attributes to your component element, e.g. <MyComponent propName={someValue} />.",
      code: false,
    },
  },
  {
    id: 6,
    topic: "React Native",
    question:
      "How can you define default prop values for a functional component in React Native?",
    code: false,
    language: false,
    options: [
      {
        text: "Using static defaultProps on the component function",
        code: false,
      },
      { text: "Using MyComponent.propDefaults", code: false },
      { text: "Using MyComponent.defaultProps = {}", code: false },
      {
        text: "You cannot define defaultProps in a functional component",
        code: false,
      },
    ],
    answer: "Using MyComponent.defaultProps = {}",
    explanation: {
      text: "Functional components can have defaultProps by assigning a defaultProps property to the component function.",
      code: false,
    },
  },

  // 7–9: STATE & HOOKS
  {
    id: 7,
    topic: "React Native",
    question:
      "Which Hook is used to manage local state in a functional React Native component?",
    code: false,
    language: false,
    options: [
      { text: "useContext", code: false },
      { text: "useReducer", code: false },
      { text: "useState", code: false },
      { text: "useLayoutEffect", code: false },
    ],
    answer: "useState",
    explanation: {
      text: "useState is the basic Hook for managing local state in functional React components (including React Native).",
      code: false,
    },
  },
  {
    id: 8,
    topic: "React Native",
    question:
      "Which Hook is used to perform side effects, like data fetching or event listeners?",
    code: false,
    language: false,
    options: [
      { text: "useMemo", code: false },
      { text: "useEffect", code: false },
      { text: "useCallback", code: false },
      { text: "useLayoutEffect", code: false },
    ],
    answer: "useEffect",
    explanation: {
      text: "useEffect runs after the component renders, enabling side effects like data fetching, subscriptions, or event handling.",
      code: false,
    },
  },
  {
    id: 9,
    topic: "React Native",
    question:
      "Which statement about lifecycle methods vs. Hooks in React Native is true?",
    code: false,
    language: false,
    options: [
      {
        text: "Hooks can only replace setState, not lifecycle methods",
        code: false,
      },
      { text: "Hooks are not supported in React Native", code: false },
      {
        text: "Hooks can replace most class-based lifecycle methods (componentDidMount, etc.) with useEffect",
        code: false,
      },
      {
        text: "Lifecycle methods must still be used even in function components",
        code: false,
      },
    ],
    answer:
      "Hooks can replace most class-based lifecycle methods (componentDidMount, etc.) with useEffect",
    explanation: {
      text: "Using useEffect, you can replicate many lifecycle methods in functional components, including componentDidMount, componentDidUpdate, and componentWillUnmount.",
      code: false,
    },
  },

  // 10–12: STYLING & LAYOUT
  {
    id: 10,
    topic: "React Native",
    question:
      "Which statement best describes how Flexbox works in React Native by default?",
    code: false,
    language: false,
    options: [
      {
        text: "React Native uses row-based flex direction by default, just like in web CSS",
        code: false,
      },
      {
        text: "React Native does not support Flexbox",
        code: false,
      },
      {
        text: "React Native defaults to column-based flex direction",
        code: false,
      },
      {
        text: "Flexbox must be enabled via StyleSheet.configure()",
        code: false,
      },
    ],
    answer: "React Native defaults to column-based flex direction",
    explanation: {
      text: "Unlike standard CSS on the web (which defaults to row), React Native flex containers default to flexDirection: 'column'.",
      code: false,
    },
  },
  {
    id: 11,
    topic: "React Native",
    question: "How do you apply styles to components in React Native?",
    code: false,
    language: false,
    options: [
      { text: "By writing CSS files and importing them", code: false },
      {
        text: "Using inline style objects or StyleSheet.create()",
        code: false,
      },
      { text: "Using <style> tags at the top of the JS file", code: false },
      {
        text: "By referencing an external .css file with a link tag, as in web development",
        code: false,
      },
    ],
    answer: "Using inline style objects or StyleSheet.create()",
    explanation: {
      text: "React Native uses JavaScript objects for styling, typically via the StyleSheet API or inline styles. There's no DOM-based CSS cascade.",
      code: false,
    },
  },
  {
    id: 12,
    topic: "React Native",
    question:
      "What is the primary benefit of using `StyleSheet.create` in React Native?",
    code: false,
    language: false,
    options: [
      {
        text: "It allows using normal CSS syntax in React Native files",
        code: false,
      },
      {
        text: "It converts styles to CSS classes behind the scenes",
        code: false,
      },
      {
        text: "It provides a performance optimization by creating a stylesheet reference",
        code: false,
      },
      {
        text: "It automatically minifies and combines styles for production",
        code: false,
      },
    ],
    answer:
      "It provides a performance optimization by creating a stylesheet reference",
    explanation: {
      text: "`StyleSheet.create` helps validate style properties and can potentially optimize references to the styles, though the performance difference is often minimal compared to inline styles.",
      code: false,
    },
  },

  // 13–15: NAVIGATION
  {
    id: 13,
    topic: "React Native",
    question:
      "Which library is most commonly used for navigation in React Native?",
    code: false,
    language: false,
    options: [
      { text: "React Router Native", code: false },
      { text: "React Navigation", code: false },
      { text: "Native Navigator", code: false },
      { text: "Navigator.js", code: false },
    ],
    answer: "React Navigation",
    explanation: {
      text: "React Navigation is a widely used library for handling routing and navigation in React Native apps (Stack, Tab, Drawer, etc.).",
      code: false,
    },
  },
  {
    id: 14,
    topic: "React Native",
    question:
      "What is the main purpose of a Stack Navigator in React Navigation?",
    code: false,
    language: false,
    options: [
      {
        text: "To display multiple screens side-by-side in a horizontal layout",
        code: false,
      },
      {
        text: "To render screens in a stack, allowing you to push/pop screens on top of each other",
        code: false,
      },
      {
        text: "To provide a bottom tab bar with multiple routes",
        code: false,
      },
      { text: "To manage form inputs within a single screen", code: false },
    ],
    answer:
      "To render screens in a stack, allowing you to push/pop screens on top of each other",
    explanation: {
      text: "A Stack Navigator allows you to navigate forward to a new screen, and go back by popping a screen off the stack, mimicking typical smartphone navigation.",
      code: false,
    },
  },
  {
    id: 15,
    topic: "React Native",
    question:
      "How do you pass parameters to a screen in React Navigation (v6)?",
    code: false,
    language: false,
    options: [
      { text: "Using the globalParams object", code: false },
      {
        text: "By directly modifying the route parameter on the destination screen",
        code: false,
      },
      {
        text: "Using navigation.navigate('ScreenName', { paramName: value })",
        code: false,
      },
      { text: "Parameters cannot be passed in React Navigation", code: false },
    ],
    answer: "Using navigation.navigate('ScreenName', { paramName: value })",
    explanation: {
      text: "You can pass parameters as a second argument to navigation.navigate, which become accessible via route.params on the destination screen.",
      code: false,
    },
  },

  // 16–18: STATE MANAGEMENT (BEYOND BASIC HOOKS)
  {
    id: 16,
    topic: "React Native",
    question:
      "What is one primary benefit of using Redux in a React Native application?",
    code: false,
    language: false,
    options: [
      {
        text: "It automatically styles your components based on app state",
        code: false,
      },
      {
        text: "It provides a centralized store for predictable state management",
        code: false,
      },
      {
        text: "It replaces the need for navigation libraries",
        code: false,
      },
      {
        text: "It automatically persists data to the device without any configuration",
        code: false,
      },
    ],
    answer: "It provides a centralized store for predictable state management",
    explanation: {
      text: "Redux helps keep all state in a single store, making data flow predictable and easier to debug.",
      code: false,
    },
  },
  {
    id: 17,
    topic: "React Native",
    question:
      "What does the `useReducer` Hook provide as an alternative to Redux in some cases?",
    code: false,
    language: false,
    options: [
      { text: "Automatic code splitting", code: false },
      { text: "A built-in context store for SSR", code: false },
      {
        text: "A way to manage complex local state with actions and reducers without a global store",
        code: false,
      },
      {
        text: "A simpler form of side-effect management than useEffect",
        code: false,
      },
    ],
    answer:
      "A way to manage complex local state with actions and reducers without a global store",
    explanation: {
      text: "useReducer is useful for local state that follows a reducer pattern, though it doesn’t replace global state solutions in all cases.",
      code: false,
    },
  },
  {
    id: 18,
    topic: "React Native",
    question:
      "Which statement best describes the difference between using the Context API vs. Redux for global state in React Native?",
    code: false,
    language: false,
    options: [
      {
        text: "Context API forces you to write more boilerplate than Redux",
        code: false,
      },
      {
        text: "Redux is typically used for large-scale or complex state, while Context API can handle simpler or more localized needs",
        code: false,
      },
      {
        text: "Context API can only store numbers, while Redux can store objects",
        code: false,
      },
      {
        text: "They are the same; Redux is just a special version of useContext",
        code: false,
      },
    ],
    answer:
      "Redux is typically used for large-scale or complex state, while Context API can handle simpler or more localized needs",
    explanation: {
      text: "Redux excels at managing highly complex or frequently updated data across many components. Context API is simpler and works well for smaller apps or less frequent updates.",
      code: false,
    },
  },

  // 19–21: HANDLING INPUTS & FORMS
  {
    id: 19,
    topic: "React Native",
    question:
      "Which component is typically used for text input in React Native?",
    code: false,
    language: false,
    options: [
      { text: "TextField", code: false },
      { text: "Input", code: false },
      { text: "TextInput", code: false },
      { text: "EditText", code: false },
    ],
    answer: "TextInput",
    explanation: {
      text: "TextInput is the core component provided by React Native for text entry.",
      code: false,
    },
  },
  {
    id: 20,
    topic: "React Native",
    question:
      "How can you prevent the on-screen keyboard from covering input fields on smaller screens in React Native?",
    code: false,
    language: false,
    options: [
      {
        text: "Use a custom scroll view library that automatically resizes components",
        code: false,
      },
      {
        text: "Use KeyboardAvoidingView or ScrollView with keyboardShouldPersistTaps",
        code: false,
      },
      {
        text: "React Native automatically does this; no extra configuration is needed",
        code: false,
      },
      {
        text: "Disable the keyboard in the AndroidManifest.xml",
        code: false,
      },
    ],
    answer:
      "Use KeyboardAvoidingView or ScrollView with keyboardShouldPersistTaps",
    explanation: {
      text: "KeyboardAvoidingView can adjust layout based on the keyboard’s appearance. Alternatively, a ScrollView can help ensure fields remain visible.",
      code: false,
    },
  },
  {
    id: 21,
    topic: "React Native",
    question:
      "Which library is often used for form handling and validation in React Native?",
    code: false,
    language: false,
    options: [
      { text: "React Navigator", code: false },
      { text: "Formik", code: false },
      { text: "AsyncStorage", code: false },
      { text: "Node Validator", code: false },
    ],
    answer: "Formik",
    explanation: {
      text: "Formik (or React Hook Form) is popular for managing forms, handling validation, and simplifying state management for inputs.",
      code: false,
    },
  },

  // 22–24: PLATFORM APIs & NATIVE MODULES
  {
    id: 22,
    topic: "React Native",
    question:
      "How do you typically access the camera or photo library in a React Native app?",
    code: false,
    language: false,
    options: [
      {
        text: "By directly querying the device’s file system with fs API",
        code: false,
      },
      {
        text: "Using a library like react-native-image-picker or Expo ImagePicker",
        code: false,
      },
      {
        text: "It’s not possible to access the camera in React Native",
        code: false,
      },
      {
        text: "By calling the iOS or Android camera function from the CLI",
        code: false,
      },
    ],
    answer:
      "Using a library like react-native-image-picker or Expo ImagePicker",
    explanation: {
      text: "React Native can’t natively access device hardware unless you use bridging or a third-party module. Popular libraries handle these details.",
      code: false,
    },
  },
  {
    id: 23,
    topic: "React Native",
    question: "What are Native Modules in React Native?",
    code: false,
    language: false,
    options: [
      {
        text: "Modules that only work on iOS but not on Android",
        code: false,
      },
      {
        text: "JS libraries that are pre-bundled with React Native",
        code: false,
      },
      {
        text: "Custom Objective-C/Swift or Java/Kotlin modules exposed to JavaScript for device-level functionality",
        code: false,
      },
      {
        text: "A type of built-in debug tool for bridging device logs",
        code: false,
      },
    ],
    answer:
      "Custom Objective-C/Swift or Java/Kotlin modules exposed to JavaScript for device-level functionality",
    explanation: {
      text: "Native Modules allow you to write native code (iOS/Android) and then expose that functionality to your React Native JavaScript code.",
      code: false,
    },
  },
  {
    id: 24,
    topic: "React Native",
    question:
      "Which statement about linking native modules in React Native is correct?",
    code: false,
    language: false,
    options: [
      {
        text: "Manual linking is always required to install any third-party module",
        code: false,
      },
      {
        text: "Autolinking is supported for many React Native libraries, removing the need for manual linking",
        code: false,
      },
      {
        text: "Linking is not needed if you are only using iOS, not Android",
        code: false,
      },
      {
        text: "Linking is only for bridging Swift code; Java modules need a separate process",
        code: false,
      },
    ],
    answer:
      "Autolinking is supported for many React Native libraries, removing the need for manual linking",
    explanation: {
      text: "As of React Native 0.60+, many libraries support automatic linking, which makes bridging native dependencies simpler.",
      code: false,
    },
  },

  // 25–27: NETWORKING & DATA FETCHING
  {
    id: 25,
    topic: "React Native",
    question:
      "What is a key difference between `fetch` and `Axios` for making HTTP requests in React Native?",
    code: false,
    language: false,
    options: [
      {
        text: "fetch returns Promises, Axios does not",
        code: false,
      },
      {
        text: "fetch is built-in, while Axios is a third-party library providing additional features like interceptors",
        code: false,
      },
      {
        text: "Axios is slower than fetch for all use cases",
        code: false,
      },
      {
        text: "You cannot handle JSON responses with fetch",
        code: false,
      },
    ],
    answer:
      "fetch is built-in, while Axios is a third-party library providing additional features like interceptors",
    explanation: {
      text: "fetch comes with React Native (part of the window/global scope), whereas Axios is a separate library offering convenience features such as automatic JSON transformations, interceptors, and more robust error handling.",
      code: false,
    },
  },
  {
    id: 26,
    topic: "React Native",
    question:
      "How do you handle an HTTP response in React Native using async/await?",
    code: false,
    language: false,
    options: [
      {
        text: "Use a callback function passed to fetch",
        code: false,
      },
      {
        text: "Use try/catch around an await fetch(...) call, then parse the JSON in another await",
        code: false,
      },
      {
        text: "You cannot use async/await with React Native",
        code: false,
      },
      {
        text: "Use the event loop directly to handle fetch responses",
        code: false,
      },
    ],
    answer:
      "Use try/catch around an await fetch(...) call, then parse the JSON in another await",
    explanation: {
      text: "Async/await allows you to write asynchronous code more synchronously. Typically, you do `const res = await fetch(url)`, and then `const data = await res.json()`, handling errors in a try/catch.",
      code: false,
    },
  },
  {
    id: 27,
    topic: "React Native",
    question:
      "Which storage solution can be used for caching or offline data in React Native?",
    code: false,
    language: false,
    options: [
      { text: "LocalStorage (like in the browser)", code: false },
      { text: "IndexedDB", code: false },
      { text: "AsyncStorage or libraries built on top of it", code: false },
      { text: "Redux DevTools", code: false },
    ],
    answer: "AsyncStorage or libraries built on top of it",
    explanation: {
      text: "AsyncStorage is a simple, unencrypted, asynchronous, persistent, key-value storage system in React Native. Libraries like @react-native-async-storage/async-storage are commonly used, or you can opt for more robust solutions like Realm or SQLite.",
      code: false,
    },
  },

  // 28–30: PERFORMANCE & OPTIMIZATION
  {
    id: 28,
    topic: "React Native",
    question:
      "Which component is recommended for rendering long, scrollable lists in React Native?",
    code: false,
    language: false,
    options: [
      { text: "ListView", code: false },
      { text: "FlatList", code: false },
      { text: "AnimatedList", code: false },
      { text: "ScrollView", code: false },
    ],
    answer: "FlatList",
    explanation: {
      text: "FlatList provides efficient scrolling of a large list of data by rendering only the items that are currently visible (and some buffer). ListView is deprecated, while ScrollView renders all items at once.",
      code: false,
    },
  },
  {
    id: 29,
    topic: "React Native",
    question:
      "What is the purpose of `React.memo` or `memo` in a React Native component?",
    code: false,
    language: false,
    options: [
      {
        text: "To render a component on every state change in the app",
        code: false,
      },
      {
        text: "To memoize HTTP requests for offline use",
        code: false,
      },
      {
        text: "To prevent unnecessary re-renders by shallow comparing props",
        code: false,
      },
      {
        text: "To enable the use of Hooks in class components",
        code: false,
      },
    ],
    answer: "To prevent unnecessary re-renders by shallow comparing props",
    explanation: {
      text: "memo (for functional components) and React.PureComponent (for class components) compare props to avoid re-rendering components that haven’t actually changed.",
      code: false,
    },
  },
  {
    id: 30,
    topic: "React Native",
    question:
      "How can you optimize rendering of a large list with complex row components in React Native?",
    code: false,
    language: false,
    options: [
      {
        text: "Use ScrollView and hope for the best",
        code: false,
      },
      {
        text: "Use FlatList with keyExtractor, getItemLayout, and possibly windowing or virtualization",
        code: false,
      },
      {
        text: "Render the entire list at once, then manually remove items off-screen",
        code: false,
      },
      {
        text: "There is no way to optimize this in React Native",
        code: false,
      },
    ],
    answer:
      "Use FlatList with keyExtractor, getItemLayout, and possibly windowing or virtualization",
    explanation: {
      text: "FlatList has built-in virtualization, and providing keyExtractor, getItemLayout, or using windowSize can further improve performance for large data sets.",
      code: false,
    },
  },

  // 31–33: DEBUGGING & DEVELOPER TOOLS
  {
    id: 31,
    topic: "React Native",
    question:
      "Which is a common way to debug a React Native app on a real device or emulator?",
    code: false,
    language: false,
    options: [
      {
        text: "Use the built-in Safari for iOS, or Chrome/ADB for Android, toggling 'Debug JS Remotely' from the in-app developer menu",
        code: false,
      },
      {
        text: "There is no official way to debug React Native on a real device",
        code: false,
      },
      {
        text: "Only console.log statements are supported; there's no dev menu",
        code: false,
      },
      {
        text: "Use Xcode or Android Studio but they cannot see JavaScript logs",
        code: false,
      },
    ],
    answer:
      "Use the built-in Safari for iOS, or Chrome/ADB for Android, toggling 'Debug JS Remotely' from the in-app developer menu",
    explanation: {
      text: "By shaking the device or pressing Cmd+D (iOS simulator) / Ctrl+M (Android emulator), you can open the dev menu, enabling remote JS debugging in a Chrome or Safari window. Tools like Flipper are also available.",
      code: false,
    },
  },
  {
    id: 32,
    topic: "React Native",
    question: "What is the 'LogBox' (previously 'YellowBox') in React Native?",
    code: false,
    language: false,
    options: [
      { text: "A tool for advanced performance monitoring", code: false },
      {
        text: "A feature for surfacing and categorizing warnings in development mode",
        code: false,
      },
      {
        text: "An alternative console specifically for logging debug info to disk",
        code: false,
      },
      {
        text: "A service that uploads logs to a cloud provider automatically",
        code: false,
      },
    ],
    answer:
      "A feature for surfacing and categorizing warnings in development mode",
    explanation: {
      text: "LogBox (formerly YellowBox) shows warnings and potential issues in your app. You can ignore or fix them based on your needs.",
      code: false,
    },
  },
  {
    id: 33,
    topic: "React Native",
    question:
      "How can you display log messages in the React Native CLI while running your app?",
    code: false,
    language: false,
    options: [
      {
        text: "Use console.log in your code and run 'react-native log-ios' or 'react-native log-android'",
        code: false,
      },
      {
        text: "You must attach a third-party logging library",
        code: false,
      },
      {
        text: "It is not possible to see logs outside of the device screen",
        code: false,
      },
      {
        text: "Only network requests can be logged in the CLI, not general logs",
        code: false,
      },
    ],
    answer:
      "Use console.log in your code and run 'react-native log-ios' or 'react-native log-android'",
    explanation: {
      text: "React Native provides commands like `react-native log-android` to see console logs from your running app directly in the terminal.",
      code: false,
    },
  },

  // 34–36: TESTING
  {
    id: 34,
    topic: "React Native",
    question:
      "Which testing framework is commonly used for unit testing React Native components?",
    code: false,
    language: false,
    options: [
      { text: "Mocha/Chai only", code: false },
      { text: "Jest", code: false },
      { text: "Cypress", code: false },
      { text: "CucumberJS", code: false },
    ],
    answer: "Jest",
    explanation: {
      text: "Jest is the default recommended testing framework that ships with React and works seamlessly with React Native for unit tests and snapshot tests.",
      code: false,
    },
  },
  {
    id: 35,
    topic: "React Native",
    question:
      "Which library helps with component-level testing in React Native, allowing you to render components and interact with them in tests?",
    code: false,
    language: false,
    options: [
      { text: "React Native CLI", code: false },
      { text: "Axios", code: false },
      { text: "React Native Testing Library", code: false },
      { text: "Lodash", code: false },
    ],
    answer: "React Native Testing Library",
    explanation: {
      text: "React Native Testing Library (based on React Testing Library) makes it easier to test React Native components in a way that resembles real user interactions.",
      code: false,
    },
  },
  {
    id: 36,
    topic: "React Native",
    question: "What is Detox used for in React Native development?",
    code: false,
    language: false,
    options: [
      {
        text: "A library for automatically cleaning up memory leaks",
        code: false,
      },
      {
        text: "An end-to-end testing framework for React Native apps",
        code: false,
      },
      {
        text: "A debugging tool that integrates with the React Native dev menu",
        code: false,
      },
      {
        text: "A code formatter similar to Prettier",
        code: false,
      },
    ],
    answer: "An end-to-end testing framework for React Native apps",
    explanation: {
      text: "Detox automates user flows on real devices or emulators, letting you run high-level integration tests for your React Native app.",
      code: false,
    },
  },

  // 37–38: BUILDING & DEPLOYMENT
  {
    id: 37,
    topic: "React Native",
    question:
      "Which command is used to generate a release APK/AAB for Android in a React Native CLI project?",
    code: false,
    language: false,
    options: [
      { text: "npm run build-android", code: false },
      { text: "gradlew assembleRelease (inside android/ folder)", code: false },
      { text: "expo build:android", code: false },
      { text: "react-native start --release", code: false },
    ],
    answer: "gradlew assembleRelease (inside android/ folder)",
    explanation: {
      text: "For React Native CLI projects on Android, you typically run `cd android && ./gradlew assembleRelease` to generate a release APK or AAB. For Expo projects, the process differs (e.g., `expo build:android`).",
      code: false,
    },
  },
  {
    id: 38,
    topic: "React Native",
    question:
      "What is Microsoft CodePush, and how does it benefit React Native deployment?",
    code: false,
    language: false,
    options: [
      {
        text: "A code editor built by Microsoft specifically for React Native",
        code: false,
      },
      {
        text: "A service for over-the-air (OTA) updates of JavaScript bundles without re-submitting to app stores",
        code: false,
      },
      {
        text: "A testing framework for writing unit tests in C#",
        code: false,
      },
      {
        text: "A library for bridging Windows Phone OS APIs to React Native",
        code: false,
      },
    ],
    answer:
      "A service for over-the-air (OTA) updates of JavaScript bundles without re-submitting to app stores",
    explanation: {
      text: "CodePush allows you to deploy JavaScript code changes and assets directly to users without going through the standard App Store / Play Store approval process.",
      code: false,
    },
  },

  // 39–40: BEST PRACTICES & MISC
  {
    id: 39,
    topic: "React Native",
    question:
      "Which approach is generally recommended for organizing files in a larger React Native project?",
    code: false,
    language: false,
    options: [
      {
        text: "All files in a single folder called 'components'",
        code: false,
      },
      {
        text: "Using feature-based or domain-based folder structures (e.g., screens, components, services, etc.)",
        code: false,
      },
      {
        text: "Placing JavaScript files directly in the android or ios folders",
        code: false,
      },
      {
        text: "Using 'wwwroot' and 'css' folders like a web project",
        code: false,
      },
    ],
    answer:
      "Using feature-based or domain-based folder structures (e.g., screens, components, services, etc.)",
    explanation: {
      text: "A common best practice is to separate code by feature/domain rather than lumping everything in a single folder. This keeps larger projects organized and maintainable.",
      code: false,
    },
  },
  {
    id: 40,
    topic: "React Native",
    question: "Which statement about accessibility in React Native is true?",
    code: false,
    language: false,
    options: [
      {
        text: "React Native fully ignores accessibility options; developers must build everything manually",
        code: false,
      },
      {
        text: "Accessibility is automatically perfect on iOS but impossible on Android",
        code: false,
      },
      {
        text: "React Native supports accessibility features like accessibilityLabel, accessible, and importantForAccessibility",
        code: false,
      },
      {
        text: "There's no concept of screen readers in mobile, so accessibility is optional",
        code: false,
      },
    ],
    answer:
      "React Native supports accessibility features like accessibilityLabel, accessible, and importantForAccessibility",
    explanation: {
      text: "React Native provides props to improve accessibility for screen readers and other assistive technologies. It’s recommended to make your app accessible on both iOS and Android.",
      code: false,
    },
  },
];
