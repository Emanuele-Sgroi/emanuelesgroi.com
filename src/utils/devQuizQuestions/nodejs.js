/**
 * NOTE: All question sets here (and their Q&A pairs) were generated by AI
 * to help with knowledge retention across a variety of technical topics.
 *
 * This File Contains the questions used in Dev Quiz.
 * It holds arrays of question objects, each representing a specific technical area.
 *
 * Each question object has the following structure:
 * - `id`: A unique identifier for the question.
 * - `topic`: The subject or category of the question (e.g., React, JavaScript, Node.js).
 * - `question`: The text of the question being asked.
 * - `language`: (Optional) A string indicating the programming language for code-related questions.
 * - `code`: (Optional) A boolean indicating if the question involves code.
 * - `options`: An array of possible answers, each with a `text` property and an optional `code` property.
 * - `answer`: The correct answer for the question.
 * - `explanation`: An explanation of why the answer is correct, with optional code examples.
 *
 * Topic covered in this file:
 * - Node.js (Event Loop, Modules, File System)
 */

export const nodeJsQuestions = [
  // 1–4: CORE MODULES (fs, path, os, http)
  {
    id: 1,
    topic: "Node.js",
    question:
      "Which core module is used to work with the file system in Node.js?",
    code: false,
    language: false,
    options: [
      { text: "path", code: false },
      { text: "os", code: false },
      { text: "fs", code: false },
      { text: "http", code: false },
    ],
    answer: "fs",
    explanation: {
      text: "The 'fs' module provides an API for interacting with the file system in Node.js.",
      code: false,
    },
  },
  {
    id: 2,
    topic: "Node.js",
    question:
      "Which core module provides utilities for working with file and directory paths?",
    code: false,
    language: false,
    options: [
      { text: "fs", code: false },
      { text: "path", code: false },
      { text: "http", code: false },
      { text: "os", code: false },
    ],
    answer: "path",
    explanation: {
      text: "The 'path' module helps in handling and transforming file paths.",
      code: false,
    },
  },
  {
    id: 3,
    topic: "Node.js",
    question: "Which method of the 'http' module creates a new HTTP server?",
    code: false,
    language: false,
    options: [
      { text: "http.get()", code: false },
      { text: "http.request()", code: false },
      { text: "http.createServer()", code: false },
      { text: "http.Server()", code: false },
    ],
    answer: "http.createServer()",
    explanation: {
      text: "The 'http.createServer()' method returns a new web server object.",
      code: false,
    },
  },
  {
    id: 4,
    topic: "Node.js",
    question:
      "Which core module provides operating system-related utility methods and properties?",
    code: false,
    language: false,
    options: [
      { text: "process", code: false },
      { text: "cluster", code: false },
      { text: "os", code: false },
      { text: "events", code: false },
    ],
    answer: "os",
    explanation: {
      text: "The 'os' module provides a number of operating system-related utility methods and properties.",
      code: false,
    },
  },

  // 5–8: EVENT LOOP & ASYNC (Call stack, event queue, timers, setImmediate)
  {
    id: 5,
    topic: "Node.js",
    question: "What is the Node.js event loop responsible for?",
    code: false,
    language: false,
    options: [
      { text: "Running only synchronous code", code: false },
      { text: "Managing and dispatching asynchronous callbacks", code: false },
      { text: "Compiling C++ add-ons", code: false },
      { text: "Rendering front-end templates", code: false },
    ],
    answer: "Managing and dispatching asynchronous callbacks",
    explanation: {
      text: "The event loop is the core mechanism that processes asynchronous operations and their callbacks in Node.js.",
      code: false,
    },
  },
  {
    id: 6,
    topic: "Node.js",
    question:
      "In which phase of the event loop are callbacks scheduled by setTimeout() and setInterval() executed?",
    code: false,
    language: false,
    options: [
      { text: "Poll phase", code: false },
      { text: "Timers phase", code: false },
      { text: "Check phase", code: false },
      { text: "Close callbacks phase", code: false },
    ],
    answer: "Timers phase",
    explanation: {
      text: "Callbacks set by setTimeout() and setInterval() are executed in the Timers phase of the Node.js event loop.",
      code: false,
    },
  },
  {
    id: 7,
    topic: "Node.js",
    question:
      "What is the difference between setImmediate() and setTimeout(fn, 0) in Node.js?",
    code: false,
    language: false,
    options: [
      {
        text: "setImmediate() runs immediately, setTimeout(fn, 0) is never called",
        code: false,
      },
      {
        text: "setImmediate() runs after I/O events, setTimeout(fn, 0) schedules a callback in the Timers phase",
        code: false,
      },
      {
        text: "They are both aliases for the same function",
        code: false,
      },
      {
        text: "setImmediate() always runs before setTimeout(fn, 0)",
        code: false,
      },
    ],
    answer:
      "setImmediate() runs after I/O events, setTimeout(fn, 0) schedules a callback in the Timers phase",
    explanation: {
      text: "setTimeout(fn, 0) executes in the Timers phase, while setImmediate(fn) executes after the Poll phase in the Check phase.",
      code: false,
    },
  },
  {
    id: 8,
    topic: "Node.js",
    question:
      "Which built-in module in Node.js can be used to handle and emit custom events?",
    code: false,
    language: false,
    options: [
      { text: "events", code: false },
      { text: "stream", code: false },
      { text: "util", code: false },
      { text: "dns", code: false },
    ],
    answer: "events",
    explanation: {
      text: "The 'events' module allows you to create, fire, and listen to your own events in Node.js using EventEmitter.",
      code: false,
    },
  },

  // 9–11: COMMONJS & ES MODULES (require vs import, module.exports)
  {
    id: 9,
    topic: "Node.js",
    question:
      "Which syntax is used by CommonJS for importing modules in Node.js?",
    code: false,
    language: false,
    options: [
      { text: "import myModule from 'myModule'", code: false },
      { text: "const myModule = require('myModule')", code: false },
      { text: "include 'myModule'", code: false },
      { text: "load('myModule')", code: false },
    ],
    answer: "const myModule = require('myModule')",
    explanation: {
      text: "CommonJS uses require() to import modules. ES Modules use import statements.",
      code: false,
    },
  },
  {
    id: 10,
    topic: "Node.js",
    question: "How do you export a module in CommonJS?",
    code: false,
    language: false,
    options: [
      { text: "export default myFunc", code: false },
      { text: "module.export = myFunc", code: false },
      { text: "module.exports = myFunc", code: false },
      { text: "exports(myFunc)", code: false },
    ],
    answer: "module.exports = myFunc",
    explanation: {
      text: "In CommonJS, module.exports is used to define what a module exports. ES Modules typically use export statements.",
      code: false,
    },
  },
  {
    id: 11,
    topic: "Node.js",
    question:
      "Which property or file extension tells Node.js to treat your code as an ES Module instead of CommonJS?",
    code: false,
    language: false,
    options: [
      {
        text: "Adding 'type': 'module' in package.json or using .mjs extension",
        code: false,
      },
      { text: "Using .esm extension only", code: false },
      { text: "Using the 'export' keyword exclusively", code: false },
      { text: "There is no way to do that in Node.js", code: false },
    ],
    answer: "Adding 'type': 'module' in package.json or using .mjs extension",
    explanation: {
      text: "You can add 'type': 'module' in package.json or rename your files to .mjs to enable ES Module support in Node.js.",
      code: false,
    },
  },

  // 12–14: FILE SYSTEM (read/write files, sync vs async methods)
  {
    id: 12,
    topic: "Node.js",
    question:
      "Which method can be used to read a file asynchronously in Node.js?",
    code: false,
    language: false,
    options: [
      { text: "fs.readFileSync()", code: false },
      { text: "fs.read()", code: false },
      { text: "fs.readFile()", code: false },
      { text: "fs.streamFile()", code: false },
    ],
    answer: "fs.readFile()",
    explanation: {
      text: "fs.readFile() is the asynchronous method for reading files. fs.readFileSync() is the synchronous counterpart.",
      code: false,
    },
  },
  {
    id: 13,
    topic: "Node.js",
    question:
      "Which of the following methods writes data to a file synchronously?",
    code: false,
    language: false,
    options: [
      { text: "fs.writeFile()", code: false },
      { text: "fs.write()", code: false },
      { text: "fs.writeFileSync()", code: false },
      { text: "fs.syncWrite()", code: false },
    ],
    answer: "fs.writeFileSync()",
    explanation: {
      text: "fs.writeFileSync() blocks the event loop until the file has been written, while fs.writeFile() is asynchronous.",
      code: false,
    },
  },
  {
    id: 14,
    topic: "Node.js",
    question:
      "How do you properly handle file system errors with fs.readFile()?",
    code: false,
    language: false,
    options: [
      {
        text: "Ignore the error parameter in the callback",
        code: false,
      },
      {
        text: "Use a try/catch around fs.readFile()",
        code: false,
      },
      {
        text: "Check the error argument in the callback or promise rejection",
        code: false,
      },
      {
        text: "No error handling is necessary",
        code: false,
      },
    ],
    answer: "Check the error argument in the callback or promise rejection",
    explanation: {
      text: "In asynchronous methods, Node.js passes the error as the first callback argument. If using promises, handle with .catch().",
      code: false,
    },
  },

  // 15–17: PROCESS & ENVIRONMENT (process.env, argv, exit, cwd)
  {
    id: 15,
    topic: "Node.js",
    question:
      "How do you access environment variables in a Node.js application?",
    code: false,
    language: false,
    options: [
      { text: "process.env", code: false },
      { text: "env.process", code: false },
      { text: "os.env", code: false },
      { text: "global.envVars", code: false },
    ],
    answer: "process.env",
    explanation: {
      text: "Environment variables are exposed in Node.js through the process.env object.",
      code: false,
    },
  },
  {
    id: 16,
    topic: "Node.js",
    question: "Which property in Node.js provides the command-line arguments?",
    code: false,
    language: false,
    options: [
      { text: "process.args", code: false },
      { text: "process.argv", code: false },
      { text: "process.commandLine", code: false },
      { text: "os.arguments", code: false },
    ],
    answer: "process.argv",
    explanation: {
      text: "process.argv is an array containing the command-line arguments passed when the Node.js process was launched.",
      code: false,
    },
  },
  {
    id: 17,
    topic: "Node.js",
    question: "How do you exit a Node.js process programmatically?",
    code: false,
    language: false,
    options: [
      { text: "process.stop()", code: false },
      { text: "process.exit()", code: false },
      { text: "exit.process()", code: false },
      { text: "global.exit()", code: false },
    ],
    answer: "process.exit()",
    explanation: {
      text: "Calling process.exit() will immediately end the Node.js process with the specified exit code (default is 0).",
      code: false,
    },
  },

  // 18–19: NPM & PACKAGE MANAGEMENT (dependencies, scripts, versioning)
  {
    id: 18,
    topic: "Node.js",
    question:
      "Which section of the package.json file lists the production dependencies of a project?",
    code: false,
    language: false,
    options: [
      { text: "peerDependencies", code: false },
      { text: "devDependencies", code: false },
      { text: "dependencies", code: false },
      { text: "bundledDependencies", code: false },
    ],
    answer: "dependencies",
    explanation: {
      text: "dependencies in package.json are libraries required by your project in production. devDependencies are usually for development/testing.",
      code: false,
    },
  },
  {
    id: 19,
    topic: "Node.js",
    question:
      "How do you run a script named 'build' defined in your package.json?",
    code: false,
    language: false,
    options: [
      { text: "npm build", code: false },
      { text: "node build", code: false },
      { text: "npm run build", code: false },
      { text: "npm script build", code: false },
    ],
    answer: "npm run build",
    explanation: {
      text: "Scripts in package.json can be executed with 'npm run <scriptName>'.",
      code: false,
    },
  },

  // 20–23: EXPRESS.JS BASICS (Routes, middleware, req/res)
  {
    id: 20,
    topic: "Node.js",
    question:
      "Which method is used to define a route for GET requests in an Express app?",
    code: false,
    language: false,
    options: [
      { text: "app.router()", code: false },
      { text: "app.route()", code: false },
      { text: "app.get()", code: false },
      { text: "app.fetch()", code: false },
    ],
    answer: "app.get()",
    explanation: {
      text: "app.get(path, callback) is used to handle GET requests in Express.",
      code: false,
    },
  },
  {
    id: 21,
    topic: "Node.js",
    question: "In Express.js, what is middleware?",
    code: false,
    language: false,
    options: [
      { text: "An HTTP server replacement", code: false },
      {
        text: "A function that runs during the request/response cycle",
        code: false,
      },
      { text: "A database driver", code: false },
      { text: "A logging utility", code: false },
    ],
    answer: "A function that runs during the request/response cycle",
    explanation: {
      text: "Middleware are functions that have access to the req and res objects and can modify them or end the request-response process.",
      code: false,
    },
  },
  {
    id: 22,
    topic: "Node.js",
    question: "How do you access URL parameters (e.g., :id) in Express?",
    code: `app.get("/users/:id", (req, res) => {
  // ?
});`,
    language: "javascript",
    options: [
      { text: "req.body", code: false },
      { text: "req.params", code: false },
      { text: "req.query", code: false },
      { text: "req.id", code: false },
    ],
    answer: "req.params",
    explanation: {
      text: "In Express, named route parameters are captured in req.params. For query strings, use req.query.",
      code: false,
    },
  },
  {
    id: 23,
    topic: "Node.js",
    question:
      "Which object in an Express route handler is used to send a response back to the client?",
    code: false,
    language: false,
    options: [
      { text: "req", code: false },
      { text: "res", code: false },
      { text: "next", code: false },
      { text: "app", code: false },
    ],
    answer: "res",
    explanation: {
      text: "res (short for response) is used to send back the HTTP response (e.g., res.send, res.json).",
      code: false,
    },
  },

  // 24–25: ERROR HANDLING & DEBUGGING (try/catch, async errors, debugging tools)
  {
    id: 24,
    topic: "Node.js",
    question: "How do you handle errors in an async/await function in Node.js?",
    code: false,
    language: false,
    options: [
      {
        text: "Use a try/catch block or handle promise rejections",
        code: false,
      },
      { text: "Node.js automatically handles async errors", code: false },
      { text: "Ignore them because they never occur", code: false },
      { text: "Wrap the code in a synchronous function", code: false },
    ],
    answer: "Use a try/catch block or handle promise rejections",
    explanation: {
      text: "With async/await, you can wrap await calls in try/catch or chain a .catch() on the Promise to handle errors.",
      code: false,
    },
  },
  {
    id: 25,
    topic: "Node.js",
    question:
      "Which Node.js built-in feature allows you to debug your application with breakpoints?",
    code: false,
    language: false,
    options: [
      { text: "The 'debugger' statement and 'node inspect'", code: false },
      { text: "fs debugger method", code: false },
      { text: "setImmediate debugging", code: false },
      { text: "require('debugger') module", code: false },
    ],
    answer: "The 'debugger' statement and 'node inspect'",
    explanation: {
      text: "You can use the 'debugger' keyword in your code and run 'node inspect' to pause execution at breakpoints.",
      code: false,
    },
  },

  // 26–27: MISCELLANEOUS (Global objects, REPL, Node.js CLI tools)
  {
    id: 26,
    topic: "Node.js",
    question:
      "Which global object in Node.js is used to handle the current module's exports?",
    code: false,
    language: false,
    options: [
      { text: "globalThis", code: false },
      { text: "process", code: false },
      { text: "module and exports", code: false },
      { text: "window", code: false },
    ],
    answer: "module and exports",
    explanation: {
      text: "In CommonJS, 'module' and 'exports' are global-like objects that control what a file exports.",
      code: false,
    },
  },
  {
    id: 27,
    topic: "Node.js",
    question: "What is the Node.js REPL used for?",
    code: false,
    language: false,
    options: [
      { text: "A remote event processing library", code: false },
      { text: "A built-in testing framework", code: false },
      {
        text: "An interactive shell for executing JavaScript code",
        code: false,
      },
      { text: "A tool for bundling modules", code: false },
    ],
    answer: "An interactive shell for executing JavaScript code",
    explanation: {
      text: "REPL stands for Read-Eval-Print Loop, allowing you to quickly test and explore JavaScript/Node.js code in an interactive shell.",
      code: false,
    },
  },

  // 28–29: STREAMS
  {
    id: 28,
    topic: "Node.js",
    question: "What is a stream in Node.js?",
    code: false,
    language: false,
    options: [
      { text: "A function that blocks the event loop", code: false },
      {
        text: "A synchronous I/O method for reading/writing data",
        code: false,
      },
      {
        text: "An object that handles continuous reading or writing of data",
        code: false,
      },
      {
        text: "A type of child process created by the 'child_process' module",
        code: false,
      },
    ],
    answer: "An object that handles continuous reading or writing of data",
    explanation: {
      text: "Streams are Node.js' way of handling continuous I/O of data. They can be readable, writable, duplex, or transform streams, and they help with processing data efficiently without reading it all into memory at once.",
      code: false,
    },
  },
  {
    id: 29,
    topic: "Node.js",
    question:
      "What is backpressure in Node.js streams, and how can it be handled?",
    code: false,
    language: false,
    options: [
      {
        text: "When a writable stream closes unexpectedly; handled by catching 'close' events",
        code: false,
      },
      {
        text: "When the OS restricts memory usage in Node; handled by the 'mem' module",
        code: false,
      },
      {
        text: "When a writable stream receives data faster than it can consume; handled by pausing or listening for 'drain' events",
        code: false,
      },
      {
        text: "When a stream automatically flushes internal buffers; handled by 'stream.flush()'",
        code: false,
      },
    ],
    answer:
      "When a writable stream receives data faster than it can consume; handled by pausing or listening for 'drain' events",
    explanation: {
      text: "Backpressure occurs if the consumer of a stream cannot process data as quickly as it’s received. In Node.js, you typically handle this by checking the return value of .write(), listening for 'drain', or pausing/resuming the stream.",
      code: false,
    },
  },

  // 30–31: CHILD PROCESSES
  {
    id: 30,
    topic: "Node.js",
    question:
      "Which method is used to spawn a new process without buffering the output?",
    code: false,
    language: false,
    options: [
      { text: "child_process.exec()", code: false },
      { text: "child_process.spawn()", code: false },
      { text: "child_process.fork()", code: false },
      { text: "child_process.run()", code: false },
    ],
    answer: "child_process.spawn()",
    explanation: {
      text: "child_process.spawn() launches a new process and streams the I/O between the parent and child. By contrast, exec() buffers the output and is best for smaller tasks.",
      code: false,
    },
  },
  {
    id: 31,
    topic: "Node.js",
    question:
      "What is the main difference between child_process.spawn() and child_process.exec()?",
    code: false,
    language: false,
    options: [
      {
        text: "exec() streams data, spawn() buffers data",
        code: false,
      },
      {
        text: "spawn() buffers output and returns it all at once, exec() provides streaming I/O",
        code: false,
      },
      {
        text: "spawn() can handle large outputs via streams, exec() buffers the entire output in memory",
        code: false,
      },
      {
        text: "They are identical except for the command syntax",
        code: false,
      },
    ],
    answer:
      "spawn() can handle large outputs via streams, exec() buffers the entire output in memory",
    explanation: {
      text: "spawn() is suitable for long-running processes or large data, as it streams the output. exec() buffers the entire output, making it simpler for smaller tasks.",
      code: false,
    },
  },

  // 32–33: SECURITY & BEST PRACTICES
  {
    id: 32,
    topic: "Node.js",
    question:
      "Which middleware can help set various HTTP headers for security in an Express app?",
    code: false,
    language: false,
    options: [
      { text: "cors", code: false },
      { text: "helmet", code: false },
      { text: "cookie-parser", code: false },
      { text: "morgan", code: false },
    ],
    answer: "helmet",
    explanation: {
      text: "Helmet is a collection of middleware functions that help set secure HTTP headers in Express-based apps, preventing common vulnerabilities.",
      code: false,
    },
  },
  {
    id: 33,
    topic: "Node.js",
    question:
      "Which practice helps secure sensitive configuration data (e.g., API keys) in Node.js?",
    code: false,
    language: false,
    options: [
      {
        text: "Storing secrets directly in code and committing to Git",
        code: false,
      },
      {
        text: "Using environment variables or .env files with a .gitignore",
        code: false,
      },
      { text: "Keeping all secrets in an unencrypted JSON file", code: false },
      { text: "Hard-coding secrets into package.json", code: false },
    ],
    answer: "Using environment variables or .env files with a .gitignore",
    explanation: {
      text: "For security, sensitive data should never be committed to public repositories. Environment variables (or .env files) keep secrets out of the codebase and can be added to .gitignore.",
      code: false,
    },
  },

  // 34–35: PERFORMANCE & CLUSTERING
  {
    id: 34,
    topic: "Node.js",
    question: "How does the Node.js 'cluster' module help improve performance?",
    code: false,
    language: false,
    options: [
      { text: "By bundling and minifying JS files automatically", code: false },
      {
        text: "By allowing multiple workers to share the same server port and utilize multiple CPU cores",
        code: false,
      },
      { text: "By enabling hot module reloading", code: false },
      { text: "By automatically caching API responses", code: false },
    ],
    answer:
      "By allowing multiple workers to share the same server port and utilize multiple CPU cores",
    explanation: {
      text: "Cluster allows you to create child processes (workers) that share server ports, making better use of multi-core systems.",
      code: false,
    },
  },
  {
    id: 35,
    topic: "Node.js",
    question:
      "Which tool or approach is commonly used for load balancing a clustered Node.js application?",
    code: false,
    language: false,
    options: [
      {
        text: "Using Node.js' built-in HTTP server without clustering",
        code: false,
      },
      {
        text: "Using a process manager like PM2 or an external load balancer (e.g., Nginx)",
        code: false,
      },
      { text: "Using 'fs' module to route requests", code: false },
      {
        text: "Using a single instance with multiple setImmediate() calls",
        code: false,
      },
    ],
    answer:
      "Using a process manager like PM2 or an external load balancer (e.g., Nginx)",
    explanation: {
      text: "Tools like PM2 or Nginx (as a reverse proxy) are common approaches to load balancing multiple Node.js cluster workers or processes.",
      code: false,
    },
  },

  // 36–37: TESTING & DEBUGGING
  {
    id: 36,
    topic: "Node.js",
    question:
      "Which testing framework is often used to write and run tests in Node.js applications?",
    code: false,
    language: false,
    options: [
      { text: "Mocha or Jest", code: false },
      { text: "Babel", code: false },
      { text: "Express", code: false },
      { text: "Webpack", code: false },
    ],
    answer: "Mocha or Jest",
    explanation: {
      text: "Mocha and Jest are two popular testing frameworks for Node.js. They allow you to define test suites and assertions for various parts of your application.",
      code: false,
    },
  },
  {
    id: 37,
    topic: "Node.js",
    question:
      "How can you debug Node.js applications using the built-in tools?",
    code: false,
    language: false,
    options: [
      {
        text: "Add the 'debugger' statement in the code and use 'node inspect' or Chrome DevTools",
        code: false,
      },
      {
        text: "Only console.log() can be used; there are no built-in tools",
        code: false,
      },
      { text: "You must install a third-party native module", code: false },
      { text: "Use the 'fs' module to log debug info to a file", code: false },
    ],
    answer:
      "Add the 'debugger' statement in the code and use 'node inspect' or Chrome DevTools",
    explanation: {
      text: "You can insert 'debugger' in your code, then run 'node inspect <file.js>' (or attach Chrome DevTools) to debug Node.js applications.",
      code: false,
    },
  },
];
