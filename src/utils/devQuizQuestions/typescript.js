/**
 * NOTE: All question sets here (and their Q&A pairs) were generated by AI
 * to help with knowledge retention across a variety of technical topics.
 *
 * This File Contains the questions used in Dev Quiz.
 * It holds arrays of question objects, each representing a specific technical area.
 *
 * Each question object has the following structure:
 * - `id`: A unique identifier for the question.
 * - `topic`: The subject or category of the question (e.g., React, JavaScript, Node.js).
 * - `question`: The text of the question being asked.
 * - `language`: (Optional) A string indicating the programming language for code-related questions.
 * - `code`: (Optional) A boolean indicating if the question involves code.
 * - `options`: An array of possible answers, each with a `text` property and an optional `code` property.
 * - `answer`: The correct answer for the question.
 * - `explanation`: An explanation of why the answer is correct, with optional code examples.
 *
 * Topic covered in this file:
 * - TypeScript (Types, Generics, Compiler Options)
 */

export const typeScriptQuestions = [
  // 1–30: STANDARD MULTIPLE-CHOICE

  {
    id: 1,
    topic: "TypeScript",
    question:
      "Which TypeScript type is safer than 'any' and forces you to narrow it before usage?",
    code: false,
    language: false,
    options: [
      { text: "unknown", code: false },
      { text: "never", code: false },
      { text: "undefined", code: false },
      { text: "object", code: false },
    ],
    answer: "unknown",
    explanation: {
      text: "`unknown` must be narrowed by checks or type assertions before it's used. By contrast, `any` lets you do anything without type safety.",
      code: false,
    },
  },
  {
    id: 2,
    topic: "TypeScript",
    question:
      "Which statement is true regarding 'interface' vs. 'type' aliases in TypeScript?",
    code: false,
    language: false,
    options: [
      {
        text: "Type aliases cannot create union types, only interfaces can",
        code: false,
      },
      {
        text: "Interfaces support declaration merging, while type aliases do not",
        code: false,
      },
      {
        text: "Type aliases are limited to object shapes, but interfaces can define primitives",
        code: false,
      },
      {
        text: "They are fully interchangeable in every scenario",
        code: false,
      },
    ],
    answer: "Interfaces support declaration merging, while type aliases do not",
    explanation: {
      text: "Type aliases are more flexible for unions, intersections, etc. Interfaces allow declaration merging and are mainly used to describe object shapes or classes.",
      code: false,
    },
  },
  {
    id: 3,
    topic: "TypeScript",
    question: "What is the purpose of the 'strictNullChecks' compiler option?",
    code: false,
    language: false,
    options: [
      {
        text: "It disallows using 'null' and 'undefined' entirely in the codebase",
        code: false,
      },
      {
        text: "It treats 'null' and 'undefined' as distinct types that must be explicitly handled",
        code: false,
      },
      {
        text: "It automatically replaces 'null' with an empty string",
        code: false,
      },
      {
        text: "It forces all variables to be nullable by default",
        code: false,
      },
    ],
    answer:
      "It treats 'null' and 'undefined' as distinct types that must be explicitly handled",
    explanation: {
      text: "When 'strictNullChecks' is enabled, 'null' and 'undefined' are not assignable to other types without a union, reducing runtime errors from unhandled null/undefined.",
      code: false,
    },
  },
  {
    id: 4,
    topic: "TypeScript",
    question: "Which of these describes 'structural typing' in TypeScript?",
    code: false,
    language: false,
    options: [
      {
        text: "Objects must share the same class to be considered compatible",
        code: false,
      },
      {
        text: "Compatibility is based on the shape (properties/methods) rather than explicit declarations",
        code: false,
      },
      {
        text: "It requires the 'declare structural' directive in tsconfig.json",
        code: false,
      },
      {
        text: "It only applies to primitive types like string or number",
        code: false,
      },
    ],
    answer:
      "Compatibility is based on the shape (properties/methods) rather than explicit declarations",
    explanation: {
      text: "TypeScript’s type system is structural, meaning two types are compatible if they have the same structure, regardless of whether they share the same explicit type name.",
      code: false,
    },
  },
  {
    id: 5,
    topic: "TypeScript",
    question:
      "Which type is used to represent a value that logically should never occur (e.g., a function that never returns)?",
    code: false,
    language: false,
    options: [
      { text: "unknown", code: false },
      { text: "never", code: false },
      { text: "void", code: false },
      { text: "any", code: false },
    ],
    answer: "never",
    explanation: {
      text: "A function returning 'never' indicates it either throws an error or loops forever, thus never producing a value.",
      code: false,
    },
  },
  {
    id: 6,
    topic: "TypeScript",
    question:
      "Which utility type makes all properties of a given type optional?",
    code: false,
    language: false,
    options: [
      { text: "Required<T>", code: false },
      { text: "Partial<T>", code: false },
      { text: "Pick<T>", code: false },
      { text: "Record<K, T>", code: false },
    ],
    answer: "Partial<T>",
    explanation: {
      text: "Partial<T> constructs a new type with all properties of T set to optional. Required<T> is the opposite, making them non-optional.",
      code: false,
    },
  },
  {
    id: 7,
    topic: "TypeScript",
    question:
      "Which approach is used to create an intersection type from two or more existing types?",
    code: false,
    language: false,
    options: [
      { text: "Using the & operator (e.g. TypeA & TypeB)", code: false },
      { text: "Using the + operator (e.g. TypeA + TypeB)", code: false },
      { text: "Using extends TypeA, TypeB in an interface", code: false },
      { text: "Using the union operator (TypeA | TypeB)", code: false },
    ],
    answer: "Using the & operator (e.g. TypeA & TypeB)",
    explanation: {
      text: "The ampersand (&) in TypeScript forms an intersection type, requiring the resulting type to satisfy both TypeA and TypeB simultaneously.",
      code: false,
    },
  },
  {
    id: 8,
    topic: "TypeScript",
    question:
      "How do you specify that a generic type parameter extends another type?",
    code: false,
    language: false,
    options: [
      { text: "function foo<T inherits U>(arg: T) {}", code: false },
      { text: "function foo<T extends U>(arg: T) {}", code: false },
      { text: "function foo<T => U>(arg: T) {}", code: false },
      { text: "function foo<T : U>(arg: T) {}", code: false },
    ],
    answer: "function foo<T extends U>(arg: T) {}",
    explanation: {
      text: "In TypeScript generics, 'extends' is used to constrain T to a subtype of U.",
      code: false,
    },
  },
  {
    id: 9,
    topic: "TypeScript",
    question:
      "Which compile option in tsconfig.json allows you to output both .js and corresponding .d.ts files for library usage?",
    code: false,
    language: false,
    options: [
      { text: "allowJs", code: false },
      { text: "declaration", code: false },
      { text: "removeComments", code: false },
      { text: "esModuleInterop", code: false },
    ],
    answer: "declaration",
    explanation: {
      text: "Setting `declaration: true` emits .d.ts files alongside your compiled .js, enabling external usage of your type definitions.",
      code: false,
    },
  },
  {
    id: 10,
    topic: "TypeScript",
    question:
      "Which is the correct way to define a numeric enum in TypeScript?",
    code: false,
    language: false,
    options: [
      {
        text: "type MyEnum = { A: 0, B: 1, C: 2 }",
        code: false,
      },
      {
        text: "enum MyEnum { A, B, C }",
        code: false,
      },
      {
        text: "interface MyEnum { A: 0, B: 1, C: 2 }",
        code: false,
      },
      {
        text: "You cannot define numeric enums in TypeScript",
        code: false,
      },
    ],
    answer: "enum MyEnum { A, B, C }",
    explanation: {
      text: "Numeric enums in TypeScript can be created with the 'enum' keyword. By default, A=0, B=1, C=2 if not explicitly assigned.",
      code: false,
    },
  },
  {
    id: 11,
    topic: "TypeScript",
    question:
      "Which TypeScript feature is used to check for a property or type at runtime before using it, narrowing the type in a conditional block?",
    code: false,
    language: false,
    options: [
      { text: "Type assertion", code: false },
      { text: "Type guard", code: false },
      { text: "Ambient declaration", code: false },
      { text: "Type erasure", code: false },
    ],
    answer: "Type guard",
    explanation: {
      text: "A type guard is a function or expression (like 'typeof x === \"string\"') that refines the type of a variable within a conditional block.",
      code: false,
    },
  },
  {
    id: 12,
    topic: "TypeScript",
    question:
      "Which command is commonly used to compile TypeScript to JavaScript if you have a local tsconfig.json?",
    code: false,
    language: false,
    options: [
      { text: "tsc", code: false },
      { text: "ts-compile", code: false },
      { text: "typescript compile", code: false },
      { text: "babel ts files", code: false },
    ],
    answer: "tsc",
    explanation: {
      text: "Running `tsc` in a directory with tsconfig.json compiles TypeScript files into the configured JavaScript output.",
      code: false,
    },
  },
  {
    id: 13,
    topic: "TypeScript",
    question:
      "How does TypeScript interpret the 'as const' assertion on an array or object?",
    code: false,
    language: false,
    options: [
      {
        text: "It makes the array or object read-only and infers literal types for elements",
        code: false,
      },
      { text: "It casts the array or object to type 'any'", code: false },
      {
        text: "It prevents the object from being exported as a module",
        code: false,
      },
      { text: "It changes the compile target to ESNext", code: false },
    ],
    answer:
      "It makes the array or object read-only and infers literal types for elements",
    explanation: {
      text: "Using 'as const' tells TypeScript to treat array elements or object properties as constant (immutable) and infer narrow literal types instead of broader ones.",
      code: false,
    },
  },
  {
    id: 14,
    topic: "TypeScript",
    question: "What does the 'noImplicitAny' compiler option enforce?",
    code: false,
    language: false,
    options: [
      {
        text: "All variables must explicitly be declared as 'any'",
        code: false,
      },
      {
        text: "Functions and variables with no type infer 'any' implicitly",
        code: false,
      },
      {
        text: "An error is thrown when the compiler infers a type of 'any' for a variable or function parameter",
        code: false,
      },
      {
        text: "It automatically converts all 'any' types to 'unknown'",
        code: false,
      },
    ],
    answer:
      "An error is thrown when the compiler infers a type of 'any' for a variable or function parameter",
    explanation: {
      text: "With noImplicitAny, you must provide explicit type annotations or ensure the compiler can infer a more specific type. Otherwise, it raises an error.",
      code: false,
    },
  },
  {
    id: 15,
    topic: "TypeScript",
    question:
      "Which type in TypeScript is used for values that may be a 'string' or 'number', but nothing else?",
    code: false,
    language: false,
    options: [
      { text: "union of string and number (string | number)", code: false },
      { text: "any", code: false },
      { text: "never", code: false },
      { text: "unknown", code: false },
    ],
    answer: "union of string and number (string | number)",
    explanation: {
      text: "A union type (string | number) restricts values to either 'string' or 'number', disallowing other types without further checks or conversions.",
      code: false,
    },
  },
  {
    id: 16,
    topic: "TypeScript",
    question:
      "When using 'declare' in a .d.ts file, what is it typically used for?",
    code: false,
    language: false,
    options: [
      {
        text: "Defining actual runtime implementations for classes or functions",
        code: false,
      },
      {
        text: "Creating ambient declarations for types that exist at runtime but not in TypeScript",
        code: false,
      },
      {
        text: "Marking a function as deprecated",
        code: false,
      },
      {
        text: "Enabling strict mode in TypeScript",
        code: false,
      },
    ],
    answer:
      "Creating ambient declarations for types that exist at runtime but not in TypeScript",
    explanation: {
      text: "The 'declare' keyword in .d.ts files creates type declarations for external libraries or global variables without providing an implementation. It’s purely for type information.",
      code: false,
    },
  },
  {
    id: 17,
    topic: "TypeScript",
    question:
      "Which is a difference between 'public' and 'private' members in a TypeScript class?",
    code: false,
    language: false,
    options: [
      { text: "private members can be accessed from anywhere", code: false },
      {
        text: "public is the default visibility, private restricts access within the class only",
        code: false,
      },
      {
        text: "private is only recognized at runtime, not compile-time",
        code: false,
      },
      {
        text: "There is no difference, both are effectively the same in TypeScript",
        code: false,
      },
    ],
    answer:
      "public is the default visibility, private restricts access within the class only",
    explanation: {
      text: "In TypeScript, members are public by default. private restricts usage to the class itself. TypeScript enforces this at compile-time (not at runtime).",
      code: false,
    },
  },
  {
    id: 18,
    topic: "TypeScript",
    question:
      "Which type best describes a function that does not return a value?",
    code: false,
    language: false,
    options: [
      { text: "never", code: false },
      { text: "unknown", code: false },
      { text: "void", code: false },
      { text: "any", code: false },
    ],
    answer: "void",
    explanation: {
      text: "A function returning void does not have a usable return value. 'never' indicates a function that never completes at all (throw or infinite loop).",
      code: false,
    },
  },
  {
    id: 19,
    topic: "TypeScript",
    question: "Which statement about 'decorators' in TypeScript is correct?",
    code: false,
    language: false,
    options: [
      {
        text: "They are always enabled by default in every TypeScript project",
        code: false,
      },
      {
        text: "They are an experimental feature requiring 'experimentalDecorators' in tsconfig",
        code: false,
      },
      {
        text: "They only work for third-party libraries, not user-defined classes",
        code: false,
      },
      {
        text: "They are used to create union types on the fly",
        code: false,
      },
    ],
    answer:
      "They are an experimental feature requiring 'experimentalDecorators' in tsconfig",
    explanation: {
      text: "Decorators must be enabled via 'experimentalDecorators': true. They let you annotate and modify classes, methods, properties, etc., at design time.",
      code: false,
    },
  },
  {
    id: 20,
    topic: "TypeScript",
    question:
      "Which type of import/export syntax is supported by 'esModuleInterop' or 'allowSyntheticDefaultImports' in TypeScript?",
    code: false,
    language: false,
    options: [
      { text: "CommonJS require() only", code: false },
      { text: "Named AMD imports", code: false },
      {
        text: "Default imports from modules that only export = in JavaScript",
        code: false,
      },
      {
        text: "It does not affect module resolution in any way",
        code: false,
      },
    ],
    answer: "Default imports from modules that only export = in JavaScript",
    explanation: {
      text: "Enabling esModuleInterop or allowSyntheticDefaultImports allows default import syntax for modules that do not have an actual default export (like certain CommonJS modules).",
      code: false,
    },
  },
  {
    id: 21,
    topic: "TypeScript",
    question: "What is the main advantage of using 'unknown' over 'any'?",
    code: false,
    language: false,
    options: [
      {
        text: "Unknown can be assigned to other types without type checks",
        code: false,
      },
      {
        text: "Unknown forces explicit type narrowing before usage, reducing runtime errors",
        code: false,
      },
      {
        text: "Unknown is only for number-based operations",
        code: false,
      },
      {
        text: "They are identical; 'unknown' is just an alias for 'any'",
        code: false,
      },
    ],
    answer:
      "Unknown forces explicit type narrowing before usage, reducing runtime errors",
    explanation: {
      text: "Unlike 'any', you must check or assert 'unknown' before using it as a specific type. This enforces safer usage patterns.",
      code: false,
    },
  },
  {
    id: 22,
    topic: "TypeScript",
    question:
      "Which TypeScript feature helps when a function can have multiple call signatures with different parameter types?",
    code: false,
    language: false,
    options: [
      { text: "Generic constraints", code: false },
      { text: "Function overloading", code: false },
      { text: "Interface merging", code: false },
      { text: "Mapped types", code: false },
    ],
    answer: "Function overloading",
    explanation: {
      text: "Function overloading in TS allows multiple function signatures for the same function, each specifying different parameters and return types, with a single implementation.",
      code: false,
    },
  },
  {
    id: 23,
    topic: "TypeScript",
    question:
      "Which approach can convert a broad type (like string) into a more specific literal type (e.g., 'hello') at compile time?",
    code: false,
    language: false,
    options: [
      {
        text: "Using type inference in a variable with let str = 'hello' as string",
        code: false,
      },
      {
        text: "Using an explicit type assertion like const str = 'hello' as const",
        code: false,
      },
      {
        text: "TypeScript automatically narrows all string literals to literal types",
        code: false,
      },
      {
        text: "It's impossible to create literal types from string variables",
        code: false,
      },
    ],
    answer:
      "Using an explicit type assertion like const str = 'hello' as const",
    explanation: {
      text: "By default, 'hello' is typed as string, but 'as const' or a const assertion can preserve 'hello' as a string literal type.",
      code: false,
    },
  },
  {
    id: 24,
    topic: "TypeScript",
    question: "Which statement about the 'never' type is correct?",
    code: false,
    language: false,
    options: [
      {
        text: "'never' can be assigned to all other types without error",
        code: false,
      },
      {
        text: "Functions that throw exceptions or never terminate can have return type 'never'",
        code: false,
      },
      {
        text: "It's a subtype of all types except 'any'",
        code: false,
      },
      {
        text: "'never' is used to represent null or undefined",
        code: false,
      },
    ],
    answer:
      "Functions that throw exceptions or never terminate can have return type 'never'",
    explanation: {
      text: "'never' indicates code paths that cannot produce a value. It's often used for error-throwing or infinite loop functions.",
      code: false,
    },
  },
  {
    id: 25,
    topic: "TypeScript",
    question:
      "What is the effect of setting 'skipLibCheck' to true in tsconfig.json?",
    code: false,
    language: false,
    options: [
      {
        text: "It skips type checking of .d.ts files, speeding up compilation",
        code: false,
      },
      {
        text: "It skips over all compile errors in your codebase",
        code: false,
      },
      {
        text: "It disallows usage of external libraries",
        code: false,
      },
      {
        text: "It only checks code in node_modules but skips user code",
        code: false,
      },
    ],
    answer: "It skips type checking of .d.ts files, speeding up compilation",
    explanation: {
      text: "skipLibCheck = true can speed up builds by not type-checking declaration files from libraries, usually safe if those files are well-maintained.",
      code: false,
    },
  },
  {
    id: 26,
    topic: "TypeScript",
    question:
      "Which TypeScript feature allows you to transform types by iterating over properties (like creating a mapped version of each property as optional)?",
    code: false,
    language: false,
    options: [
      { text: "Mapped types", code: false },
      { text: "Index signatures", code: false },
      { text: "Polymorphic this", code: false },
      { text: "Ambient modules", code: false },
    ],
    answer: "Mapped types",
    explanation: {
      text: "Mapped types let you iterate over keys in a type (e.g. { [K in keyof T]?: T[K] }) to transform or modify property definitions.",
      code: false,
    },
  },
  {
    id: 27,
    topic: "TypeScript",
    question: "Which statement about 'any' type usage is best practice?",
    code: false,
    language: false,
    options: [
      {
        text: "'any' is recommended for all function parameters to speed coding",
        code: false,
      },
      {
        text: "Use 'any' sparingly; it disables compile-time checks and can hide errors",
        code: false,
      },
      {
        text: "'any' is safer than 'unknown'",
        code: false,
      },
      {
        text: "It is impossible to use 'any' if strict mode is on",
        code: false,
      },
    ],
    answer:
      "Use 'any' sparingly; it disables compile-time checks and can hide errors",
    explanation: {
      text: "'any' effectively opts out of type checking. It's a fallback if you can't specify a more precise type, but it should be avoided when possible.",
      code: false,
    },
  },
  {
    id: 28,
    topic: "TypeScript",
    question:
      "Which TypeScript compiler option allows default imports from modules that only export using CommonJS exports?",
    code: false,
    language: false,
    options: [
      { text: "allowJs", code: false },
      { text: "skipDefaultImports", code: false },
      { text: "allowSyntheticDefaultImports", code: false },
      { text: "resolveJsonModule", code: false },
    ],
    answer: "allowSyntheticDefaultImports",
    explanation: {
      text: "allowSyntheticDefaultImports (and esModuleInterop) let you use import foo from 'foo' even if 'foo' only exports with module.exports in plain JS.",
      code: false,
    },
  },
  {
    id: 29,
    topic: "TypeScript",
    question:
      "Which of the following statements about 'esModuleInterop' in TypeScript is correct?",
    code: false,
    language: false,
    options: [
      { text: "It prevents any usage of default imports", code: false },
      {
        text: "It enables emit __importStar and __importDefault helpers for better compatibility with CommonJS modules",
        code: false,
      },
      { text: "It is deprecated in the latest TS versions", code: false },
      {
        text: "It only works if you also disable 'strictNullChecks'",
        code: false,
      },
    ],
    answer:
      "It enables emit __importStar and __importDefault helpers for better compatibility with CommonJS modules",
    explanation: {
      text: "esModuleInterop compiles default and named imports in a way that behaves more consistently with ES module semantics, using __importStar / __importDefault under the hood.",
      code: false,
    },
  },
  {
    id: 30,
    topic: "TypeScript",
    question:
      "What is the main difference between 'interface merging' and 'type alias merging' in TypeScript?",
    code: false,
    language: false,
    options: [
      { text: "Both are fully supported in all TS versions", code: false },
      {
        text: "Interfaces can merge declarations with the same name, while type aliases cannot",
        code: false,
      },
      {
        text: "Type aliases can only merge in .d.ts files, interfaces can only merge in .ts files",
        code: false,
      },
      {
        text: "They are identical if you use the same identifier",
        code: false,
      },
    ],
    answer:
      "Interfaces can merge declarations with the same name, while type aliases cannot",
    explanation: {
      text: "Type aliases don't support merging. If you declare multiple type aliases of the same name, it’s an error. Interfaces with the same name do combine their definitions.",
      code: false,
    },
  },

  // 31–40: CODE / ERROR-SPOTTING / COMPLETION

  {
    id: 31,
    topic: "TypeScript",
    question:
      "Complete the generic function signature to ensure 'T' must be a subtype of 'number' or 'string':\n\nfunction toStrLength<T _____ (number | string)>(value: T): number {\n  return value.toString().length;\n}",
    code: `function toStrLength<T _______ (number | string)>(value: T): number {
  return value.toString().length;
}`,
    language: "typescript",
    options: [
      { text: "extends", code: false },
      { text: "super", code: false },
      { text: "implements", code: false },
      { text: ":", code: false },
    ],
    answer: "extends",
    explanation: {
      text: "Generic constraints use extends in TypeScript. Example: function toStrLength<T extends (number | string)>(value: T).",
      code: false,
    },
  },
  {
    id: 32,
    topic: "TypeScript",
    question:
      "Spot the error in the code:\n\nfunction doWork(input: any) {\n  console.log(input.toFixed(2));\n}\n\nIt compiles, but might fail at runtime. Why?",
    code: `function doWork(input: any) {
  console.log(input.toFixed(2));
}`,
    language: "typescript",
    options: [
      {
        text: "toFixed is not a valid function in JavaScript",
        code: false,
      },
      {
        text: "The code uses any, so input could be a string or object that has no toFixed method, causing runtime errors",
        code: false,
      },
      {
        text: "You must import toFixed from 'lib:math'",
        code: false,
      },
      {
        text: "input is a reserved keyword in TypeScript",
        code: false,
      },
    ],
    answer:
      "The code uses any, so input could be a string or object that has no toFixed method, causing runtime errors",
    explanation: {
      text: "Because input is 'any', there's no compile-time guarantee that it’s a number. If it's not a number, calling toFixed will crash at runtime.",
      code: false,
    },
  },
  {
    id: 33,
    topic: "TypeScript",
    question:
      "Complete the code to define an interface with an optional property:\n\ninterface Person {\n  name: string;\n  ________ age?: number;\n}",
    code: `interface Person {
  name: string;
  /* ? */ age?: number;
}`,
    language: "typescript",
    options: [
      { text: "let", code: false },
      { text: "readonly", code: false },
      { text: "public", code: false },
      { text: "// no extra keyword needed", code: false },
    ],
    answer: "// no extra keyword needed",
    explanation: {
      text: "Just age?: number is enough to make the property optional. No let/readonly/public are used inside interface property definitions in that manner.",
      code: false,
    },
  },
  {
    id: 34,
    topic: "TypeScript",
    question:
      "Why does this code produce an error?\n\nfunction greet(msg: string) {\n  msg = 42;\n  console.log(msg);\n}",
    code: `function greet(msg: string) {
  msg = 42;
  console.log(msg);
}`,
    language: "typescript",
    options: [
      {
        text: "You cannot reassign function parameters in TypeScript",
        code: false,
      },
      {
        text: "42 is not assignable to type string, causing a type error",
        code: false,
      },
      {
        text: "console.log is not allowed on msg variables",
        code: false,
      },
      {
        text: "You must declare msg with let inside the function block",
        code: false,
      },
    ],
    answer: "42 is not assignable to type string, causing a type error",
    explanation: {
      text: "Parameters typed as string cannot be assigned a number without a type assertion or union type. This violates TypeScript’s static type checking.",
      code: false,
    },
  },
  {
    id: 35,
    topic: "TypeScript",
    question:
      "Complete this function overload set so that TS can differentiate calls:\n\nfunction pick(value: string[]): string;\nfunction pick(value: number[]): number;\nfunction pick(value: (string | number)[]): string | number {\n  return value[0];\n}\n\nWhat is missing?",
    code: `function pick(value: string[]): string;
function pick(value: number[]): number;
function pick(value: (string | number)[]): string | number {
  return value[0];
}`,
    language: "typescript",
    options: [
      {
        text: "A return type annotation on the function implementation is required",
        code: false,
      },
      {
        text: "Nothing is missing, this is fully correct overload usage",
        code: false,
      },
      {
        text: "You need 'declare' in front of each signature",
        code: false,
      },
      {
        text: "An explicit function name for the implementation is needed: function pickImpl(...)",
        code: false,
      },
    ],
    answer: "Nothing is missing, this is fully correct overload usage",
    explanation: {
      text: "In TS, you define multiple overload signatures plus a single implementation signature that is compatible with all. This example is correct.",
      code: false,
    },
  },
  {
    id: 36,
    topic: "TypeScript",
    question:
      "Spot the error in the code:\n\nconst obj = {\n  title: 'Hello',\n};\nobj.title = 'World';\n\nObject.freeze(obj);\nobj.title = 'Again';\n\nIt compiles but may fail at runtime. Why?",
    code: `const obj = {
  title: 'Hello',
};
obj.title = 'World';

Object.freeze(obj);
obj.title = 'Again';`,
    language: "typescript",
    options: [
      {
        text: "TypeScript doesn't enforce immutability from Object.freeze at compile time; it still sees obj.title as writable",
        code: false,
      },
      {
        text: "You must declare the property as 'readonly title'",
        code: false,
      },
      {
        text: "You can’t use const on an object if you want to modify properties",
        code: false,
      },
      {
        text: "Object.freeze is not supported in TypeScript",
        code: false,
      },
    ],
    answer:
      "TypeScript doesn't enforce immutability from Object.freeze at compile time; it still sees obj.title as writable",
    explanation: {
      text: "Object.freeze is a runtime method; TS won't infer that 'title' is read-only. A typical fix is to cast the object as a Readonly type or use 'as const'.",
      code: false,
    },
  },
  {
    id: 37,
    topic: "TypeScript",
    question:
      "Complete the code so that 'user' is typed as a record with string keys and boolean values:\n\nconst user: ________ = {\n  isAdmin: true,\n  canEdit: false,\n};",
    code: `const user: /* ? */ = {
  isAdmin: true,
  canEdit: false,
};`,
    language: "typescript",
    options: [
      { text: "Record<string, boolean>", code: false },
      { text: "{ [key: string]: number }", code: false },
      { text: "Partial<string, boolean>", code: false },
      { text: "Map<string, boolean>", code: false },
    ],
    answer: "Record<string, boolean>",
    explanation: {
      text: "Record<K, V> is a TS utility type that creates an object type with keys of type K and values of type V. Here, K=string, V=boolean.",
      code: false,
    },
  },
  {
    id: 38,
    topic: "TypeScript",
    question:
      "Spot the error:\n\nlet val: number | null = 10;\nconsole.log(val.toFixed(2));\n\n// TS error: 'val' could be null.\n// How to fix it properly?",
    code: `let val: number | null = 10;
console.log(val.toFixed(2));`,
    language: "typescript",
    options: [
      {
        text: "Change the type to 'number' only, removing null entirely",
        code: false,
      },
      {
        text: "Narrow or check for null first, e.g. if(val !== null) console.log(val.toFixed(2))",
        code: false,
      },
      {
        text: "Use val ? val.toFixed(2) : 0 with a ternary, or non-null assertion operator",
        code: false,
      },
      {
        text: "Any approach is acceptable; TS never warns about null",
        code: false,
      },
    ],
    answer:
      "Narrow or check for null first, e.g. if(val !== null) console.log(val.toFixed(2))",
    explanation: {
      text: "Because val might be null, you must handle that possibility. Checking val !== null or using optional chaining or the non-null assertion (!) would fix the error.",
      code: false,
    },
  },
  {
    id: 39,
    topic: "TypeScript",
    question:
      "Complete the snippet:\n\nfunction getLength(arr: ReadonlyArray<string>): number {\n  return ________;\n}\n\nWe want to return the number of elements in arr, but cannot modify it.",
    code: `function getLength(arr: ReadonlyArray<string>): number {
  return /* ? */;
}`,
    language: "typescript",
    options: [
      { text: "arr.size", code: false },
      { text: "arr.length", code: false },
      { text: "arr.pop()", code: false },
      { text: "arr.splice(0,0).length", code: false },
    ],
    answer: "arr.length",
    explanation: {
      text: "A ReadonlyArray doesn't allow mutating methods, but length is still available for reading the number of elements.",
      code: false,
    },
  },
  {
    id: 40,
    topic: "TypeScript",
    question:
      "Spot the error:\n\nfunction logNames(names: string[]): void {\n  names.forEach(name => console.log(name.toUppercase()));\n}\n\nTS says: 'Property toUppercase does not exist on type string'. Correct fix?",
    code: `function logNames(names: string[]): void {
  names.forEach(name => console.log(name.toUppercase()));
}`,
    language: "typescript",
    options: [
      {
        text: "Change name: string to any so TS won't complain",
        code: false,
      },
      {
        text: "Use the correct method name toUpperCase() instead of toUppercase()",
        code: false,
      },
      {
        text: "Remove console.log calls; they're not allowed in TS",
        code: false,
      },
      {
        text: "Type assertion: (name as string).toUppercase()",
        code: false,
      },
    ],
    answer:
      "Use the correct method name toUpperCase() instead of toUppercase()",
    explanation: {
      text: "In JavaScript/TypeScript, the method is toUpperCase(), not toUppercase(). TS correctly flags a non-existent method as an error.",
      code: false,
    },
  },
];
