/**
 * NOTE: All question sets here (and their Q&A pairs) were generated by AI
 * to help with knowledge retention across a variety of technical topics.
 *
 * This File Contains the questions used in Dev Quiz.
 * It holds arrays of question objects, each representing a specific technical area.
 *
 * Each question object has the following structure:
 * - `id`: A unique identifier for the question.
 * - `topic`: The subject or category of the question (e.g., React, JavaScript, Node.js).
 * - `question`: The text of the question being asked.
 * - `language`: (Optional) A string indicating the programming language for code-related questions.
 * - `code`: (Optional) A boolean indicating if the question involves code.
 * - `options`: An array of possible answers, each with a `text` property and an optional `code` property.
 * - `answer`: The correct answer for the question.
 * - `explanation`: An explanation of why the answer is correct, with optional code examples.
 *
 * Topic covered in this file:
 * - Database (SQL vs. NoSQL, indexing, normalization, queries)
 */

export const databaseQuestions = [
  // 1–20: THEORY (RELATIONAL & NOSQL)

  {
    id: 1,
    topic: "Database",
    question:
      "Which of the following is NOT a characteristic of a relational database?",
    code: false,
    language: false,
    options: [
      {
        text: "Data is organized into tables with rows and columns",
        code: false,
      },
      {
        text: "Schema-less design enabling flexible, unstructured data",
        code: false,
      },
      { text: "Enforced relationships via foreign keys", code: false },
      { text: "SQL is typically used for queries", code: false },
    ],
    answer: "Schema-less design enabling flexible, unstructured data",
    explanation: {
      text: "Relational databases generally have a fixed schema. Schema-less or flexible data structures are more characteristic of many NoSQL databases.",
      code: false,
    },
  },
  {
    id: 2,
    topic: "Database",
    question:
      "In the context of ACID transactions, what does the 'A' stand for?",
    code: false,
    language: false,
    options: [
      { text: "Atomicity", code: false },
      { text: "Availability", code: false },
      { text: "Authentication", code: false },
      { text: "Aggregation", code: false },
    ],
    answer: "Atomicity",
    explanation: {
      text: "ACID stands for Atomicity, Consistency, Isolation, Durability—properties ensuring reliable transaction processing in relational databases.",
      code: false,
    },
  },
  {
    id: 3,
    topic: "Database",
    question:
      "Which SQL clause is used to filter rows after the GROUP BY aggregation has been applied?",
    code: false,
    language: false,
    options: [
      { text: "WHERE", code: false },
      { text: "ORDER BY", code: false },
      { text: "HAVING", code: false },
      { text: "JOIN", code: false },
    ],
    answer: "HAVING",
    explanation: {
      text: "HAVING filters aggregated results after GROUP BY. WHERE filters rows before grouping.",
      code: false,
    },
  },
  {
    id: 4,
    topic: "Database",
    question:
      "Which normal form requires that a table has no transitive dependencies on a non-key attribute?",
    code: false,
    language: false,
    options: [
      { text: "1st Normal Form", code: false },
      { text: "2nd Normal Form", code: false },
      { text: "3rd Normal Form", code: false },
      { text: "Boyce-Codd Normal Form", code: false },
    ],
    answer: "3rd Normal Form",
    explanation: {
      text: "3rd Normal Form requires no transitive dependencies of non-key attributes. In simpler terms, non-key attributes must depend only on the primary key.",
      code: false,
    },
  },
  {
    id: 5,
    topic: "Database",
    question:
      "Which of the following is an advantage of using a NoSQL database (e.g., MongoDB)?",
    code: false,
    language: false,
    options: [
      { text: "Schema is strictly enforced by default", code: false },
      {
        text: "Horizontal scaling (sharding) is often easier to implement",
        code: false,
      },
      {
        text: "Joins are natively supported at the same level as SQL",
        code: false,
      },
      { text: "They require transactions to write any data", code: false },
    ],
    answer: "Horizontal scaling (sharding) is often easier to implement",
    explanation: {
      text: "Many NoSQL systems are built for horizontal scalability, making it simpler to distribute data across multiple nodes. They often have looser schemas and limited joins.",
      code: false,
    },
  },
  {
    id: 6,
    topic: "Database",
    question:
      "Which indexing strategy is typically used to speed up equality lookups on a single column in SQL databases?",
    code: false,
    language: false,
    options: [
      { text: "B-tree index", code: false },
      { text: "Bitmap index", code: false },
      { text: "Hash index", code: false },
      { text: "Full-text index", code: false },
    ],
    answer: "Hash index",
    explanation: {
      text: "While B-trees are the default in many SQL engines for a wide range of queries, a hash index is especially optimized for equality lookups. (Note that not all RDBMS support hash indexes natively, but conceptually they’re for equality ops.)",
      code: false,
    },
  },
  {
    id: 7,
    topic: "Database",
    question:
      "Which of the following isolation levels ensures that if a transaction reads a row, no other transaction can modify that row until the first transaction completes?",
    code: false,
    language: false,
    options: [
      { text: "Read Uncommitted", code: false },
      { text: "Read Committed", code: false },
      { text: "Repeatable Read", code: false },
      { text: "Serializable", code: false },
    ],
    answer: "Serializable",
    explanation: {
      text: "Serializable is the strictest isolation level, preventing phantom reads, non-repeatable reads, and effectively serializing transactions. In practice, many engines rely on row locking or MVCC to emulate it.",
      code: false,
    },
  },
  {
    id: 8,
    topic: "Database",
    question:
      "Which SQL statement can you use to remove an entire table from the database schema?",
    code: false,
    language: false,
    options: [
      { text: "TRUNCATE TABLE table_name;", code: false },
      { text: "DROP TABLE table_name;", code: false },
      { text: "DELETE FROM table_name;", code: false },
      { text: "ALTER TABLE table_name DROP ALL;", code: false },
    ],
    answer: "DROP TABLE table_name;",
    explanation: {
      text: "DROP TABLE permanently deletes the table structure and data. TRUNCATE removes all rows but keeps the table structure.",
      code: false,
    },
  },
  {
    id: 9,
    topic: "Database",
    question: "In MongoDB, which data format is used to store documents?",
    code: false,
    language: false,
    options: [
      { text: "Plain text files", code: false },
      { text: "XML", code: false },
      { text: "BSON (binary JSON)", code: false },
      { text: "YAML", code: false },
    ],
    answer: "BSON (binary JSON)",
    explanation: {
      text: "MongoDB uses BSON, a binary-encoded JSON-like format, to store documents efficiently with additional type information (e.g., date, int).",
      code: false,
    },
  },
  {
    id: 10,
    topic: "Database",
    question:
      "Which of the following best describes 'sharding' in a database context?",
    code: false,
    language: false,
    options: [
      {
        text: "Partitioning data horizontally across multiple machines to handle large datasets or high throughput",
        code: false,
      },
      { text: "Duplicating the entire database for backup", code: false },
      {
        text: "Using columns instead of rows to store data",
        code: false,
      },
      {
        text: "Storing data on a single node with replication turned off",
        code: false,
      },
    ],
    answer:
      "Partitioning data horizontally across multiple machines to handle large datasets or high throughput",
    explanation: {
      text: "Sharding splits a dataset into smaller “shards” and distributes them, improving scalability for read/write operations across many nodes.",
      code: false,
    },
  },
  {
    id: 11,
    topic: "Database",
    question:
      "In PostgreSQL, which data type can store a JSON object while preserving indexing possibilities using a specialized index (like GIN)?",
    code: false,
    language: false,
    options: [
      { text: "TEXT", code: false },
      { text: "VARCHAR", code: false },
      { text: "JSONB", code: false },
      { text: "JSONARRAY", code: false },
    ],
    answer: "JSONB",
    explanation: {
      text: "PostgreSQL offers JSON and JSONB. JSONB is a binary-serialized JSON, allowing efficient indexing and operations on the stored data.",
      code: false,
    },
  },
  {
    id: 12,
    topic: "Database",
    question:
      "Which NoSQL model organizes data as a collection of key-value pairs, allowing extremely simple reads/writes based on a single key?",
    code: false,
    language: false,
    options: [
      { text: "Key-value store", code: false },
      { text: "Document store", code: false },
      { text: "Column-family store", code: false },
      { text: "Graph database", code: false },
    ],
    answer: "Key-value store",
    explanation: {
      text: "Key-value databases (e.g., Redis) store data as a simple key to arbitrary blob mapping, focusing on fast lookups by key.",
      code: false,
    },
  },
  {
    id: 13,
    topic: "Database",
    question: "Which statement about database transactions is correct?",
    code: false,
    language: false,
    options: [
      {
        text: "They allow partial commits of data even if errors occur during the transaction",
        code: false,
      },
      {
        text: "They bundle multiple read/write operations into a single logical unit of work, which either commits or rolls back atomically",
        code: false,
      },
      {
        text: "They are only supported in NoSQL databases",
        code: false,
      },
      {
        text: "They automatically scale writes across multiple shards with no conflicts",
        code: false,
      },
    ],
    answer:
      "They bundle multiple read/write operations into a single logical unit of work, which either commits or rolls back atomically",
    explanation: {
      text: "Transactions ensure either all or none of the operations occur (Atomicity), letting you maintain data integrity across multiple statements.",
      code: false,
    },
  },
  {
    id: 14,
    topic: "Database",
    question:
      "In MySQL or MariaDB, which storage engine supports row-level locking and transactions?",
    code: false,
    language: false,
    options: [
      { text: "MyISAM", code: false },
      { text: "InnoDB", code: false },
      { text: "CSV", code: false },
      { text: "Memory", code: false },
    ],
    answer: "InnoDB",
    explanation: {
      text: "InnoDB is a default storage engine in newer MySQL/MariaDB versions, supporting transactions, row-level locking, foreign keys, etc. MyISAM does not support transactions or row-level locking.",
      code: false,
    },
  },
  {
    id: 15,
    topic: "Database",
    question:
      "Which of the following is a common reason to use an index on a column?",
    code: false,
    language: false,
    options: [
      { text: "To slow down insert and update operations", code: false },
      { text: "To reduce disk usage", code: false },
      {
        text: "To speed up queries that filter or sort by that column",
        code: false,
      },
      { text: "To merge multiple columns into one", code: false },
    ],
    answer: "To speed up queries that filter or sort by that column",
    explanation: {
      text: "Indexes improve performance for queries that use specific columns in WHERE, JOIN, or ORDER BY clauses. However, they can slow down writes due to maintenance overhead.",
      code: false,
    },
  },
  {
    id: 16,
    topic: "Database",
    question:
      "Which of the following best describes a primary key in a relational table?",
    code: false,
    language: false,
    options: [
      {
        text: "A column or set of columns that uniquely identifies each row",
        code: false,
      },
      { text: "A foreign key referencing another table", code: false },
      {
        text: "A column that can contain duplicates or null values",
        code: false,
      },
      { text: "An automatically generated date/time column", code: false },
    ],
    answer: "A column or set of columns that uniquely identifies each row",
    explanation: {
      text: "Primary keys uniquely identify rows and cannot be NULL or duplicated, ensuring row-level integrity.",
      code: false,
    },
  },
  {
    id: 17,
    topic: "Database",
    question: "In a distributed system, what does the CAP theorem state?",
    code: false,
    language: false,
    options: [
      {
        text: "Consistency, Availability, and Partition Tolerance cannot all be guaranteed simultaneously; you must pick two",
        code: false,
      },
      {
        text: "You can achieve perfect uptime if you scale horizontally",
        code: false,
      },
      {
        text: "It’s about Column, Array, and Partition data structures",
        code: false,
      },
      {
        text: "It states that indexing columns must remain consistent with primary key constraints",
        code: false,
      },
    ],
    answer:
      "Consistency, Availability, and Partition Tolerance cannot all be guaranteed simultaneously; you must pick two",
    explanation: {
      text: "The CAP theorem says in the presence of a network partition, you must sacrifice either strict consistency or full availability. Different databases make different trade-offs.",
      code: false,
    },
  },
  {
    id: 18,
    topic: "Database",
    question: "Which statement about replication is true?",
    code: false,
    language: false,
    options: [
      { text: "It only works in NoSQL databases", code: false },
      {
        text: "A primary node can stream changes to secondary nodes, improving read scalability and fault tolerance",
        code: false,
      },
      {
        text: "It is the same as partitioning data horizontally",
        code: false,
      },
      {
        text: "It automatically merges conflicting writes without any config",
        code: false,
      },
    ],
    answer:
      "A primary node can stream changes to secondary nodes, improving read scalability and fault tolerance",
    explanation: {
      text: "In typical master-slave replication, all writes go to the master (primary) which then replicates changes to slaves (secondaries). This helps distribute reads and improves resilience against node failure.",
      code: false,
    },
  },
  {
    id: 19,
    topic: "Database",
    question: "What is a 'materialized view' in a relational database?",
    code: false,
    language: false,
    options: [
      { text: "An ephemeral temporary table used during queries", code: false },
      {
        text: "A view that is computed and stored physically, allowing faster reads but requiring refresh for updates",
        code: false,
      },
      {
        text: "A subquery that is always inlined for performance",
        code: false,
      },
      {
        text: "A built-in indexing method for columns",
        code: false,
      },
    ],
    answer:
      "A view that is computed and stored physically, allowing faster reads but requiring refresh for updates",
    explanation: {
      text: "Materialized views store the query result. They must be refreshed (manually or automatically) to stay in sync with underlying tables.",
      code: false,
    },
  },
  {
    id: 20,
    topic: "Database",
    question:
      "Which type of NoSQL database models relationships as edges between nodes, commonly used for social networks or recommendation engines?",
    code: false,
    language: false,
    options: [
      { text: "Key-value store", code: false },
      { text: "Document store", code: false },
      { text: "Column-family store", code: false },
      { text: "Graph database", code: false },
    ],
    answer: "Graph database",
    explanation: {
      text: "Graph databases (e.g., Neo4j) model data as nodes and edges, making relationship traversal very efficient for heavily connected data.",
      code: false,
    },
  },

  // 21–30: PRACTICE / CODE SNIPPETS (SQL & NoSQL)

  {
    id: 21,
    topic: "Database",
    question:
      "Given a table 'employees' with columns (id, first_name, last_name, salary), write an SQL query to select employees with a salary greater than 50000:",
    code: false,
    language: "sql",
    options: [
      {
        text: "SELECT * FROM employees WHERE salary > 50000;",
        code: true,
      },
      {
        text: "SELECT * FROM employees HAVING salary > 50000;",
        code: true,
      },
      {
        text: "SELECT employees WHERE salary > 50000;",
        code: true,
      },
      {
        text: "SELECT (id, first_name, last_name, salary) FROM employees FOR salary > 50000;",
        code: true,
      },
    ],
    answer: "SELECT * FROM employees WHERE salary > 50000;",
    explanation: {
      text: "Use a basic SELECT statement with WHERE for filtering. The HAVING clause is used after GROUP BY, so it’s not correct here.",
      code: false,
    },
  },
  {
    id: 22,
    topic: "Database",
    question:
      "Spot the error in this SQL snippet:\n\n```sql\nUPDATE users\nSET email = 'john@example.com'\nWHERE user_id == 123;\n```\n",
    code: `UPDATE users
SET email = 'john@example.com'
WHERE user_id == 123;`,
    language: "sql",
    options: [
      {
        text: "SQL uses '=' or '<>' instead of '==' for comparisons in many dialects",
        code: false,
      },
      {
        text: "You must write WHERE user_id EQUALS '123' in quotes",
        code: false,
      },
      {
        text: "UPDATE cannot set columns in the same query as WHERE",
        code: false,
      },
      {
        text: "This snippet has no error",
        code: false,
      },
    ],
    answer:
      "SQL uses '=' or '<>' instead of '==' for comparisons in many dialects",
    explanation: {
      text: "In standard SQL, the correct syntax is `WHERE user_id = 123`. The double equals (==) is not typically valid in SQL (though some specific dialects might allow it, most mainstream ones do not).",
      code: false,
    },
  },
  {
    id: 23,
    topic: "Database",
    question:
      "Given a 'posts' table with columns (id, title, content, user_id), write an SQL join to retrieve posts along with the matching username from a 'users' table (id, username). Both tables share user_id = id in users:",
    code: false,
    language: "sql",
    options: [
      {
        text: "SELECT p.*, u.username\nFROM posts p\nJOIN users u ON p.user_id = u.id;",
        code: true,
      },
      {
        text: "SELECT p.*, u.username\nFROM posts p\nWHERE p.user_id = u.id;",
        code: true,
      },
      {
        text: "SELECT p.*, u.username\nFROM posts p\nCONCAT users u ON p.user_id = u.id;",
        code: true,
      },
      {
        text: "SELECT p.*, u.username\nFROM posts p\nGROUP BY p.user_id;",
        code: true,
      },
    ],
    answer:
      "SELECT p.*, u.username\nFROM posts p\nJOIN users u ON p.user_id = u.id;",
    explanation: {
      text: "A straightforward INNER JOIN with ON p.user_id = u.id returns rows where the user exists in both tables. The second option uses WHERE but never declared a table alias for u, so it’s incomplete.",
      code: false,
    },
  },
  {
    id: 24,
    topic: "Database",
    question:
      "In MySQL, how would you remove all rows from 'orders' while resetting any AUTO_INCREMENT counters quickly, but keep the table structure?",
    code: false,
    language: "sql",
    options: [
      {
        text: "DELETE FROM orders;",
        code: true,
      },
      {
        text: "DROP TABLE orders;",
        code: true,
      },
      {
        text: "TRUNCATE TABLE orders;",
        code: true,
      },
      {
        text: "ALTER TABLE orders DELETE ALL;",
        code: true,
      },
    ],
    answer: "TRUNCATE TABLE orders;",
    explanation: {
      text: "TRUNCATE quickly deletes all data and resets auto-increment counters. DELETE FROM orders only removes rows but keeps the existing auto-increment value.",
      code: false,
    },
  },
  {
    id: 25,
    topic: "Database",
    question:
      "Which is the correct MongoDB query to find documents in 'products' collection where 'price' is less than 100?",
    code: false,
    language: "javascript",
    options: [
      {
        text: `db.products.find({ price: { $lt: 100 } })`,
        code: true,
      },
      {
        text: `db.products.find({ price: < 100 })`,
        code: true,
      },
      {
        text: `db.products.find("price < 100")`,
        code: true,
      },
      {
        text: `db.products.find($lt=100)`,
        code: true,
      },
    ],
    answer: `db.products.find({ price: { $lt: 100 } })`,
    explanation: {
      text: "MongoDB uses query operators like `$lt` for 'less than'. The correct syntax is an object with `price` key and an operator object `{ $lt: 100 }`.",
      code: false,
    },
  },
  {
    id: 26,
    topic: "Database",
    question:
      "Spot the error in this MongoDB update:\n\n```js\ndb.users.updateOne(\n  { _id: 123 },\n  { name: 'John Doe' }\n);\n```\n",
    code: `db.users.updateOne(
  { _id: 123 },
  { name: 'John Doe' }
);`,
    language: "javascript",
    options: [
      {
        text: "You must specify update operators (e.g., $set: { name: 'John Doe' })",
        code: false,
      },
      {
        text: "updateOne does not exist in MongoDB, only update",
        code: false,
      },
      {
        text: "IDs can't be numeric, so _id: 123 is invalid",
        code: false,
      },
      {
        text: "You need a write concern parameter or it fails",
        code: false,
      },
    ],
    answer:
      "You must specify update operators (e.g., $set: { name: 'John Doe' })",
    explanation: {
      text: "In MongoDB, non-replacement updates require an update operator like `$set`. Otherwise, you’re attempting a replacement update, which would remove all other fields. `updateOne()` with `{ name: 'John Doe' }` would replace the entire document except _id. If that's not intended, you should do `$set`.",
      code: false,
    },
  },
  {
    id: 27,
    topic: "Database",
    question:
      "Given a 'sales' table with columns (region, year, amount). Write a SQL query to group results by region and get the total sales per region, naming the sum as total_amount.",
    code: false,
    language: "sql",
    options: [
      {
        text: `SELECT region, SUM(amount) AS total_amount
FROM sales
GROUP BY region;`,
        code: true,
      },
      {
        text: `SELECT region, amount
FROM sales
GROUP BY region;`,
        code: true,
      },
      {
        text: `SELECT region, SUM(amount) AS total_amount
FROM sales
WHERE region = GROUP;`,
        code: true,
      },
      {
        text: `SELECT region, amount
FROM sales
HAVING SUM(amount)`,
        code: true,
      },
    ],
    answer: `SELECT region, SUM(amount) AS total_amount
FROM sales
GROUP BY region;`,
    explanation: {
      text: "Use GROUP BY region to aggregate sums. The second option doesn’t sum amounts, the third uses invalid syntax, and the fourth is incomplete.",
      code: false,
    },
  },
  {
    id: 28,
    topic: "Database",
    question:
      "How would you create an index on 'username' in a 'users' collection in MongoDB?",
    code: false,
    language: "javascript",
    options: [
      {
        text: `db.users.createIndex({ username: 1 })`,
        code: true,
      },
      {
        text: `db.users.ensureIndex({ username: 'asc' })`,
        code: true,
      },
      {
        text: `db.users.ensure({ username: 1 })`,
        code: true,
      },
      {
        text: `CREATE INDEX username ON users (username ASC);`,
        code: true,
      },
    ],
    answer: `db.users.createIndex({ username: 1 })`,
    explanation: {
      text: "`createIndex` is the standard MongoDB command. `ensureIndex` is deprecated in newer drivers. The last option is standard SQL syntax, not MongoDB.",
      code: false,
    },
  },
  {
    id: 29,
    topic: "Database",
    question:
      "Complete this SQL to rename the column 'age' to 'years' in the table 'people' (assuming a dialect that supports standard syntax):\n\n```sql\nALTER TABLE people \n    _____ age TO years;\n```",
    code: `ALTER TABLE people
    _____ age TO years;`,
    language: "sql",
    options: [
      { text: "CHANGE COLUMN", code: false },
      { text: "RENAME COLUMN", code: false },
      { text: "ALTER COLUMN", code: false },
      { text: "REPLACE COLUMN", code: false },
    ],
    answer: "RENAME COLUMN",
    explanation: {
      text: "Some RDBMS (e.g., PostgreSQL) support `ALTER TABLE table_name RENAME COLUMN old TO new;`. MySQL might require `CHANGE COLUMN age years INT;` or something else. But in standard syntax, RENAME COLUMN is typical.",
      code: false,
    },
  },
  {
    id: 30,
    topic: "Database",
    question:
      "Given a 'customers' table with columns (id, name, city). Spot the issue:\n\n```sql\nSELECT id, name\nFROM customers\nWHERE city = 'Chicago'\nGROUP BY city;\n```\n",
    code: `SELECT id, name
FROM customers
WHERE city = 'Chicago'
GROUP BY city;`,
    language: "sql",
    options: [
      {
        text: "Columns not in the GROUP BY or an aggregate function can't be selected (id, name are neither aggregated nor grouped)",
        code: false,
      },
      {
        text: "Use DISTINCT city, not GROUP BY city in this query",
        code: false,
      },
      {
        text: "You can't use WHERE with GROUP BY in the same query",
        code: false,
      },
      {
        text: "The snippet is correct, no issues",
        code: false,
      },
    ],
    answer:
      "Columns not in the GROUP BY or an aggregate function can't be selected (id, name are neither aggregated nor grouped)",
    explanation: {
      text: "In standard SQL, if you GROUP BY city, you cannot directly select id or name unless they're aggregated (e.g. MIN(name)) or included in GROUP BY. Otherwise, this query will fail or return undefined results in strict SQL modes.",
      code: false,
    },
  },
];
