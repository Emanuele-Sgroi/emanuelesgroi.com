/**
 * NOTE: All question sets here (and their Q&A pairs) were generated by AI
 * to help with knowledge retention across a variety of technical topics.
 *
 * This File Contains the questions used in Dev Quiz.
 * It holds arrays of question objects, each representing a specific technical area.
 *
 * Each question object has the following structure:
 * - `id`: A unique identifier for the question.
 * - `topic`: The subject or category of the question (e.g., React, JavaScript, Node.js).
 * - `question`: The text of the question being asked.
 * - `language`: (Optional) A string indicating the programming language for code-related questions.
 * - `code`: (Optional) A boolean indicating if the question involves code.
 * - `options`: An array of possible answers, each with a `text` property and an optional `code` property.
 * - `answer`: The correct answer for the question.
 * - `explanation`: An explanation of why the answer is correct, with optional code examples.
 *
 * Topic covered in this file:
 * - React (Hooks, Virtual DOM, Lifecycle)
 */

export const reactQuestions = [
  // REACT — HOOKS (IDs 1–10)
  {
    id: 1,
    topic: "React",
    question: "What is the primary purpose of the useState hook in React?",
    code: false,
    language: false,
    options: [
      { text: "To directly manipulate the DOM", code: false },
      { text: "To manage state in a functional component", code: false },
      { text: "To handle side effects", code: false },
      { text: "To fetch data from an API", code: false },
    ],
    answer: "To manage state in a functional component",
    explanation: {
      text: "useState allows functional components to have local state variables.",
      code: false,
    },
  },
  {
    id: 2,
    topic: "React",
    question: "What does the useEffect hook do?",
    code: false,
    language: false,
    options: [
      { text: "Renders components asynchronously", code: false },
      { text: "Applies styling to components", code: false },
      {
        text: "Handles side effects like data fetching or subscriptions",
        code: false,
      },
      { text: "Creates reusable components", code: false },
    ],
    answer: "Handles side effects like data fetching or subscriptions",
    explanation: {
      text: "useEffect runs after the render and is commonly used for side effects like API calls or setting up event listeners.",
      code: false,
    },
  },
  {
    id: 3,
    topic: "React",
    question: "What is the output of the following code?",
    language: "javascript",
    code: `const [count, setCount] = useState(0);
setCount(count + 1);
console.log(count);`,
    options: [
      { text: "0", code: false },
      { text: "1", code: false },
      { text: "undefined", code: false },
      { text: "It throws an error", code: false },
    ],
    answer: "0",
    explanation: {
      text: "React state updates are asynchronous. The console logs the old value before the state is updated.",
      code: false,
    },
  },
  {
    id: 4,
    topic: "React",
    question:
      "Which hook would you use to keep a mutable value around that doesn’t cause a re-render when updated?",
    code: false,
    language: false,
    options: [
      { text: "useMemo", code: false },
      { text: "useState", code: false },
      { text: "useCallback", code: false },
      { text: "useRef", code: false },
    ],
    answer: "useRef",
    explanation: {
      text: "useRef holds a mutable reference that persists across renders but doesn’t cause re-render when changed.",
      code: false,
    },
  },
  {
    id: 5,
    topic: "React",
    question: "What is the purpose of useMemo?",
    code: false,
    language: false,
    options: [
      { text: "To memoize expensive computations", code: false },
      { text: "To memoize component renders", code: false },
      { text: "To store refs across renders", code: false },
      { text: "To debounce API calls", code: false },
    ],
    answer: "To memoize expensive computations",
    explanation: {
      text: "useMemo caches the result of a computation and recomputes only if dependencies change.",
      code: false,
    },
  },
  {
    id: 6,
    topic: "React",
    question: "What is the difference between useMemo and useCallback?",
    code: false,
    language: false,
    options: [
      {
        text: "useMemo returns a memoized function; useCallback returns a memoized value",
        code: false,
      },
      { text: "useMemo is used for DOM manipulation", code: false },
      {
        text: "useCallback memoizes functions; useMemo memoizes computed values",
        code: false,
      },
      { text: "There is no difference", code: false },
    ],
    answer: "useCallback memoizes functions; useMemo memoizes computed values",
    explanation: {
      text: "useCallback is a specialized version of useMemo that is used for memoizing functions.",
      code: false,
    },
  },
  {
    id: 7,
    topic: "React",
    question: "What is the output of this code?",
    language: "javascript",
    code: `const [count, setCount] = useState(0);

useEffect(() => {
  setCount(count + 1);
}, []);

console.log(count);`,
    options: [
      { text: "0", code: false },
      { text: "1", code: false },
      { text: "2", code: false },
      { text: "It causes an infinite loop", code: false },
    ],
    answer: "0",
    explanation: {
      text: "The effect runs after the first render, but count is 0 at the time of render, so console logs 0.",
      code: false,
    },
  },
  {
    id: 8,
    topic: "React",
    question:
      "Which hook is best suited for managing global state within a component tree?",
    code: false,
    language: false,
    options: [
      { text: "useState", code: false },
      { text: "useMemo", code: false },
      { text: "useEffect", code: false },
      { text: "useContext", code: false },
    ],
    answer: "useContext",
    explanation: {
      text: "useContext is used to access shared state and avoid prop drilling across deeply nested components.",
      code: false,
    },
  },
  {
    id: 9,
    topic: "React",
    question:
      "What happens if you call a hook conditionally inside a component?",
    code: false,
    language: false,
    options: [
      { text: "React will optimize it", code: false },
      { text: "It will throw an error or behave unexpectedly", code: false },
      { text: "It creates a new hook instance", code: false },
      { text: "It runs only if the condition is true", code: false },
    ],
    answer: "It will throw an error or behave unexpectedly",
    explanation: {
      text: "Hooks must be called in the same order every render. Conditional calls can break the rules of hooks.",
      code: false,
    },
  },
  {
    id: 10,
    topic: "React",
    question: "What is the purpose of the dependency array in useEffect?",
    code: false,
    language: false,
    options: [
      { text: "To specify what variables trigger the effect", code: false },
      { text: "To track memory leaks", code: false },
      { text: "To define component props", code: false },
      { text: "To store previous render state", code: false },
    ],
    answer: "To specify what variables trigger the effect",
    explanation: {
      text: "The dependency array tells React when to re-run the effect based on which values have changed.",
      code: false,
    },
  },

  // REACT — COMPONENT TYPES (IDs 11–15)
  {
    id: 11,
    topic: "React",
    question:
      "What is the main difference between a class component and a functional component in React?",
    code: false,
    language: false,
    options: [
      { text: "Class components can't manage state", code: false },
      { text: "Functional components are used for routing only", code: false },
      {
        text: "Class components use lifecycle methods, functional components use hooks",
        code: false,
      },
      { text: "Functional components must return a string", code: false },
    ],
    answer:
      "Class components use lifecycle methods, functional components use hooks",
    explanation: {
      text: "Class components manage side effects with lifecycle methods like componentDidMount, while functional components use hooks like useEffect.",
      code: false,
    },
  },
  {
    id: 12,
    topic: "React",
    question: "Which of the following is a valid functional component?",
    language: "javascript",
    code: `function MyComponent() {
  return <div>Hello World</div>;
}`,
    options: [
      { text: "Yes, this is a valid functional component", code: false },
      { text: "No, functional components must use class keyword", code: false },
      { text: "No, it must return a string", code: false },
      {
        text: "No, React does not support functions as components",
        code: false,
      },
    ],
    answer: "Yes, this is a valid functional component",
    explanation: {
      text: "Functional components are JavaScript functions that return JSX.",
      code: false,
    },
  },
  {
    id: 13,
    topic: "React",
    question: "What is a prop in React?",
    code: false,
    language: false,
    options: [
      { text: "A special kind of state variable", code: false },
      { text: "An internal configuration object", code: false },
      {
        text: "An immutable value passed from parent to child component",
        code: false,
      },
      { text: "A built-in React hook", code: false },
    ],
    answer: "An immutable value passed from parent to child component",
    explanation: {
      text: "Props are used to pass data from one component to another. They are read-only and cannot be modified by the child.",
      code: false,
    },
  },
  {
    id: 14,
    topic: "React",
    question: "What is the purpose of 'defaultProps' in a class component?",
    code: false,
    language: false,
    options: [
      { text: "To define initial state", code: false },
      { text: "To set fallback values for props", code: false },
      { text: "To define class methods", code: false },
      { text: "To handle user authentication", code: false },
    ],
    answer: "To set fallback values for props",
    explanation: {
      text: "defaultProps provides default values for props if none are passed to the component.",
      code: false,
    },
  },
  {
    id: 15,
    topic: "React",
    question: "What is the role of the 'key' prop in a list of React elements?",
    code: false,
    language: false,
    options: [
      { text: "To define a unique ID for styling", code: false },
      { text: "To help React identify which items have changed", code: false },
      { text: "To optimize API calls", code: false },
      { text: "To create unique CSS classes", code: false },
    ],
    answer: "To help React identify which items have changed",
    explanation: {
      text: "Keys help React identify which elements in a list have changed, been added, or removed. It improves rendering performance.",
      code: false,
    },
  },

  // REACT — LIFECYCLE (IDs 16–19)

  {
    id: 16,
    topic: "React",
    question:
      "Which lifecycle method is invoked immediately after a component is inserted into the DOM?",
    code: false,
    language: false,
    options: [
      { text: "componentDidUpdate", code: false },
      { text: "componentWillMount", code: false },
      { text: "componentDidMount", code: false },
      { text: "render", code: false },
    ],
    answer: "componentDidMount",
    explanation: {
      text: "componentDidMount is called once after the initial render, making it ideal for API calls or subscriptions.",
      code: false,
    },
  },
  {
    id: 17,
    topic: "React",
    question:
      "What is the correct way to replicate componentDidMount in a functional component?",
    language: "javascript",
    code: `useEffect(() => {
  // logic here
}, []);`,
    options: [
      { text: "By using useState", code: false },
      {
        text: "By using useEffect with an empty dependency array",
        code: false,
      },
      { text: "By calling useEffect inside componentDidMount", code: false },
      { text: "By using useMemo", code: false },
    ],
    answer: "By using useEffect with an empty dependency array",
    explanation: {
      text: "useEffect with an empty dependency array runs only once after the initial render, just like componentDidMount.",
      code: false,
    },
  },
  {
    id: 18,
    topic: "React",
    question:
      "Which lifecycle method is commonly used for cleanup in a class component?",
    code: false,
    language: false,
    options: [
      { text: "componentDidMount", code: false },
      { text: "componentWillUnmount", code: false },
      { text: "componentDidUpdate", code: false },
      { text: "getDerivedStateFromProps", code: false },
    ],
    answer: "componentWillUnmount",
    explanation: {
      text: "componentWillUnmount is used to perform cleanup such as removing timers or unsubscribing from services before a component is removed.",
      code: false,
    },
  },
  {
    id: 19,
    topic: "React",
    question: "When does useEffect run by default?",
    code: false,
    language: false,
    options: [
      { text: "Only once after initial render", code: false },
      { text: "After every re-render", code: false },
      { text: "Only before the component unmounts", code: false },
      { text: "After state updates but not props", code: false },
    ],
    answer: "After every re-render",
    explanation: {
      text: "By default, useEffect runs after every render unless you provide a dependency array to control when it runs.",
      code: false,
    },
  },

  // REACT — JSX & RENDERING (IDs 20–23)

  {
    id: 20,
    topic: "React",
    question:
      "What is the correct way to render a list of items in React using JSX?",
    language: "javascript",
    code: `{items.map(item => (
  <li key={item.id}>{item.name}</li>
))}`,
    options: [
      { text: "Using a for loop directly inside JSX", code: false },
      { text: "Using map and assigning a key to each element", code: false },
      { text: "Using while loop in JSX return", code: false },
      { text: "Using forEach with a return statement", code: false },
    ],
    answer: "Using map and assigning a key to each element",
    explanation: {
      text: "map is the most common way to render lists in JSX. Keys help React track changes to each item.",
      code: false,
    },
  },
  {
    id: 21,
    topic: "React",
    question:
      "Which of the following is the correct way to conditionally render content in JSX?",
    language: "javascript",
    code: `{isLoggedIn ? <p>Welcome!</p> : <p>Please log in.</p>}`,
    options: [
      { text: "if (isLoggedIn) return <p>Welcome!</p>", code: false },
      { text: "Using ternary or && operators inside JSX", code: false },
      { text: "Use an if statement inside JSX", code: false },
      { text: "Wrap the JSX in a for loop", code: false },
    ],
    answer: "Using ternary or && operators inside JSX",
    explanation: {
      text: "Ternary expressions and logical && are standard for conditional rendering inside JSX.",
      code: false,
    },
  },
  {
    id: 22,
    topic: "React",
    question: "What is the purpose of using a fragment (`<>...</>`) in JSX?",
    code: false,
    language: false,
    options: [
      { text: "To create comments in JSX", code: false },
      {
        text: "To group multiple elements without adding extra nodes to the DOM",
        code: false,
      },
      { text: "To bind multiple events", code: false },
      { text: "To create loops", code: false },
    ],
    answer: "To group multiple elements without adding extra nodes to the DOM",
    explanation: {
      text: "Fragments let you return multiple elements from a component without adding extra HTML elements.",
      code: false,
    },
  },
  {
    id: 23,
    topic: "React",
    question:
      "Why is it important to provide a unique 'key' prop when rendering lists?",
    code: false,
    language: false,
    options: [
      { text: "It improves accessibility", code: false },
      {
        text: "It allows React to optimize rendering and reordering",
        code: false,
      },
      { text: "It's used for styling elements", code: false },
      { text: "It prevents runtime errors", code: false },
    ],
    answer: "It allows React to optimize rendering and reordering",
    explanation: {
      text: "Keys help React identify which elements have changed, improving performance and avoiding unnecessary re-renders.",
      code: false,
    },
  },

  // REACT — STATE MANAGEMENT (IDs 24–27)

  {
    id: 24,
    topic: "React",
    question: "What does 'lifting state up' mean in React?",
    code: false,
    language: false,
    options: [
      { text: "Storing state inside Redux", code: false },
      {
        text: "Moving state to a common ancestor to share between components",
        code: false,
      },
      { text: "Deleting unused state variables", code: false },
      { text: "Using local storage to persist state", code: false },
    ],
    answer: "Moving state to a common ancestor to share between components",
    explanation: {
      text: "Lifting state up means moving shared state to the closest common parent so multiple components can access or update it.",
      code: false,
    },
  },
  {
    id: 25,
    topic: "React",
    question: "What problem does prop drilling refer to?",
    code: false,
    language: false,
    options: [
      { text: "Passing props in incorrect order", code: false },
      { text: "Sending props in class components only", code: false },
      {
        text: "Passing props through many nested components unnecessarily",
        code: false,
      },
      { text: "Reusing props between different pages", code: false },
    ],
    answer: "Passing props through many nested components unnecessarily",
    explanation: {
      text: "Prop drilling can lead to hard-to-maintain code when props are passed down multiple levels for deeply nested components.",
      code: false,
    },
  },
  {
    id: 26,
    topic: "React",
    question: "Which hook is commonly used to avoid prop drilling?",
    code: false,
    language: false,
    options: [
      { text: "useRef", code: false },
      { text: "useContext", code: false },
      { text: "useCallback", code: false },
      { text: "useMemo", code: false },
    ],
    answer: "useContext",
    explanation: {
      text: "useContext allows sharing data across components without passing props manually at every level.",
      code: false,
    },
  },
  {
    id: 27,
    topic: "React",
    question:
      "What happens if you call setState with the same value as the current state?",
    code: false,
    language: false,
    options: [
      { text: "React will force a re-render", code: false },
      { text: "React throws an error", code: false },
      { text: "React skips re-rendering", code: false },
      { text: "React resets the component", code: false },
    ],
    answer: "React skips re-rendering",
    explanation: {
      text: "React performs a shallow comparison and skips re-rendering if the new state is equal to the current one.",
      code: false,
    },
  },

  // REACT — PERFORMANCE (IDs 28–30)

  {
    id: 28,
    topic: "React",
    question:
      "Which hook helps memoize a function to avoid unnecessary re-creations on re-renders?",
    code: false,
    language: false,
    options: [
      { text: "useMemo", code: false },
      { text: "useRef", code: false },
      { text: "useCallback", code: false },
      { text: "useEffect", code: false },
    ],
    answer: "useCallback",
    explanation: {
      text: "useCallback returns a memoized version of the callback that only changes if one of the dependencies has changed.",
      code: false,
    },
  },
  {
    id: 29,
    topic: "React",
    question: "What is the purpose of React.memo?",
    code: false,
    language: false,
    options: [
      { text: "To cache API responses", code: false },
      {
        text: "To memoize functional components and avoid unnecessary re-renders",
        code: false,
      },
      { text: "To delay rendering until needed", code: false },
      { text: "To make components load lazily", code: false },
    ],
    answer: "To memoize functional components and avoid unnecessary re-renders",
    explanation: {
      text: "React.memo is a higher-order component that prevents functional components from re-rendering if their props haven’t changed.",
      code: false,
    },
  },
  {
    id: 30,
    topic: "React",
    question: "What is the main benefit of using PureComponent in React?",
    code: false,
    language: false,
    options: [
      { text: "It allows class components to access hooks", code: false },
      { text: "It adds support for animations", code: false },
      {
        text: "It prevents re-renders when props and state haven't changed",
        code: false,
      },
      { text: "It provides better support for context", code: false },
    ],
    answer: "It prevents re-renders when props and state haven't changed",
    explanation: {
      text: "PureComponent performs a shallow comparison of props and state, improving performance by preventing unnecessary renders.",
      code: false,
    },
  },

  // REACT — FORMS & EVENTS (IDs 31–33)

  {
    id: 31,
    topic: "React",
    question: "What is a controlled component in React?",
    code: false,
    language: false,
    options: [
      { text: "A component with built-in validation", code: false },
      {
        text: "A form element whose value is controlled by React state",
        code: false,
      },
      { text: "A component rendered conditionally", code: false },
      { text: "A component that only works with Redux", code: false },
    ],
    answer: "A form element whose value is controlled by React state",
    explanation: {
      text: "Controlled components use React state as the single source of truth for form inputs, making them predictable and easy to manage.",
      code: false,
    },
  },
  {
    id: 32,
    topic: "React",
    question: "Which event handler is used to handle form submission in React?",
    code: false,
    language: false,
    options: [
      { text: "onClick", code: false },
      { text: "onChange", code: false },
      { text: "onSubmit", code: false },
      { text: "onInput", code: false },
    ],
    answer: "onSubmit",
    explanation: {
      text: "The onSubmit event is triggered when a form is submitted, usually via a submit button or pressing Enter inside a field.",
      code: false,
    },
  },
  {
    id: 33,
    topic: "React",
    question:
      "How can you prevent the default form submission behavior in React?",
    language: "javascript",
    code: `const handleSubmit = (e) => {
  e.preventDefault();
  // handle logic here
};`,
    options: [
      { text: "By returning false from the event handler", code: false },
      { text: "By using e.preventDefault()", code: false },
      { text: "By calling e.stopPropagation()", code: false },
      { text: "By removing the submit button", code: false },
    ],
    answer: "By using e.preventDefault()",
    explanation: {
      text: "Calling `e.preventDefault()` stops the browser from performing the default form submission action, allowing custom logic instead.",
      code: false,
    },
  },

  // REACT — BEST PRACTICES (IDs 34–36)

  {
    id: 34,
    topic: "React",
    question:
      "Why should you include all dependencies in the useEffect dependency array?",
    code: false,
    language: false,
    options: [
      { text: "To avoid linting errors only", code: false },
      {
        text: "To ensure the effect always runs when dependencies change",
        code: false,
      },
      { text: "To prevent the app from rendering", code: false },
      { text: "It's optional and mostly ignored by React", code: false },
    ],
    answer: "To ensure the effect always runs when dependencies change",
    explanation: {
      text: "Including all dependencies ensures the effect re-runs when any value it relies on changes, avoiding stale closures and bugs.",
      code: false,
    },
  },
  {
    id: 35,
    topic: "React",
    question:
      "Why is it recommended to use unique and stable keys when rendering lists in React?",
    code: false,
    language: false,
    options: [
      {
        text: "To prevent performance issues and maintain element identity",
        code: false,
      },
      { text: "To style list items uniquely", code: false },
      { text: "To avoid server errors", code: false },
      { text: "To reduce bundle size", code: false },
    ],
    answer: "To prevent performance issues and maintain element identity",
    explanation: {
      text: "React uses keys to track elements between renders. Unique keys help avoid bugs and unnecessary re-renders.",
      code: false,
    },
  },
  {
    id: 36,
    topic: "React",
    question:
      "What is a good alternative to deeply nested component trees with many props?",
    code: false,
    language: false,
    options: [
      { text: "Use render props", code: false },
      { text: "Use HOC for everything", code: false },
      { text: "Use dangerouslySetInnerHTML", code: false },
      { text: "Avoid using child components", code: false },
    ],
    answer: "Use render props",
    explanation: {
      text: "Render props are a pattern for sharing logic and composing components without deeply nesting or excessive prop drilling.",
      code: false,
    },
  },

  // REACT — ADVANCED CONCEPTS (IDs 37–41)

  {
    id: 37,
    topic: "React",
    question: "What is a custom hook in React?",
    code: false,
    language: false,
    options: [
      { text: "A hook provided by React", code: false },
      {
        text: "A function that uses hooks to encapsulate reusable logic",
        code: false,
      },
      { text: "A third-party library for managing state", code: false },
      { text: "A built-in React feature to style components", code: false },
    ],
    answer: "A function that uses hooks to encapsulate reusable logic",
    explanation: {
      text: "Custom hooks allow logic reuse across components by combining built-in hooks into reusable functions.",
      code: false,
    },
  },
  {
    id: 38,
    topic: "React",
    question: "What is a Higher-Order Component (HOC)?",
    code: false,
    language: false,
    options: [
      { text: "A component that renders only once", code: false },
      { text: "A component that uses Redux", code: false },
      {
        text: "A function that takes a component and returns a new enhanced component",
        code: false,
      },
      { text: "A type of error boundary", code: false },
    ],
    answer:
      "A function that takes a component and returns a new enhanced component",
    explanation: {
      text: "HOCs are functions that enhance components with extra functionality, often used for cross-cutting concerns like authentication or logging.",
      code: false,
    },
  },
  {
    id: 39,
    topic: "React",
    question: "What is the render props pattern in React?",
    code: false,
    language: false,
    options: [
      { text: "A way to define inline styles in JSX", code: false },
      {
        text: "A pattern where a component shares logic by using a prop whose value is a function",
        code: false,
      },
      { text: "A way to define custom events", code: false },
      { text: "A performance optimization technique", code: false },
    ],
    answer:
      "A pattern where a component shares logic by using a prop whose value is a function",
    explanation: {
      text: "Render props allow components to share code by passing a function that returns JSX — giving great flexibility.",
      code: false,
    },
  },
  {
    id: 40,
    topic: "React",
    question: "What is an error boundary in React?",
    code: false,
    language: false,
    options: [
      {
        text: "A way to catch and handle JavaScript errors in the component tree",
        code: false,
      },
      { text: "A tool to prevent prop drilling", code: false },
      { text: "A built-in hook for error management", code: false },
      { text: "A type of React Fragment", code: false },
    ],
    answer: "A way to catch and handle JavaScript errors in the component tree",
    explanation: {
      text: "Error boundaries are class components that implement `componentDidCatch` and `getDerivedStateFromError` to handle rendering errors gracefully.",
      code: false,
    },
  },
  {
    id: 41,
    topic: "React",
    question:
      "Which lifecycle method is used by error boundaries to catch errors?",
    code: false,
    language: false,
    options: [
      { text: "componentDidMount", code: false },
      { text: "getSnapshotBeforeUpdate", code: false },
      { text: "componentDidCatch", code: false },
      { text: "shouldComponentUpdate", code: false },
    ],
    answer: "componentDidCatch",
    explanation: {
      text: "`componentDidCatch(error, info)` is used to catch JavaScript errors anywhere in a child component tree and display a fallback UI.",
      code: false,
    },
  },

  // REACT — REACT + ECOSYSTEM (IDs 42–52)

  {
    id: 42,
    topic: "React",
    question: "What is the main purpose of Redux in a React application?",
    code: false,
    language: false,
    options: [
      { text: "To style components", code: false },
      {
        text: "To manage application-level state in a predictable way",
        code: false,
      },
      { text: "To handle routing", code: false },
      { text: "To handle asynchronous API calls", code: false },
    ],
    answer: "To manage application-level state in a predictable way",
    explanation: {
      text: "Redux centralizes state in a single store and uses actions and reducers to update that state in a predictable way.",
      code: false,
    },
  },
  {
    id: 43,
    topic: "React",
    question: "What does the `useSelector` hook do in Redux with React?",
    code: false,
    language: false,
    options: [
      { text: "Dispatch an action to the store", code: false },
      { text: "Connect a component to the store", code: false },
      { text: "Read data from the Redux store", code: false },
      { text: "Create a new reducer", code: false },
    ],
    answer: "Read data from the Redux store",
    explanation: {
      text: "`useSelector` allows you to extract data from the Redux store state using a selector function.",
      code: false,
    },
  },
  {
    id: 44,
    topic: "React",
    question: "What is the role of `useDispatch` in Redux?",
    code: false,
    language: false,
    options: [
      { text: "It replaces useEffect", code: false },
      { text: "It allows dispatching actions to the Redux store", code: false },
      { text: "It creates global state", code: false },
      { text: "It binds components to reducers", code: false },
    ],
    answer: "It allows dispatching actions to the Redux store",
    explanation: {
      text: "`useDispatch` provides a reference to the dispatch function so you can trigger actions from your components.",
      code: false,
    },
  },
  {
    id: 45,
    topic: "React",
    question: "What library is commonly used for routing in React?",
    code: false,
    language: false,
    options: [
      { text: "React Router", code: false },
      { text: "React DOM", code: false },
      { text: "Redux Router", code: false },
      { text: "Axios", code: false },
    ],
    answer: "React Router",
    explanation: {
      text: "React Router enables navigation and route-based rendering in single-page React applications.",
      code: false,
    },
  },
  {
    id: 46,
    topic: "React",
    question:
      "How do you define a route with dynamic parameters using React Router v6?",
    language: "jsx",
    code: `<Route path="/user/:id" element={<UserPage />} />`,
    options: [
      { text: `<Route path="/user/{id}" />`, code: false },
      { text: `<Route path="/user/:id" />`, code: false },
      { text: `<Route dynamic="/user/id" />`, code: false },
      { text: `<DynamicRoute to="/user/:id" />`, code: false },
    ],
    answer: `<Route path="/user/:id" />`,
    explanation: {
      text: "The colon (`:`) in the path indicates a dynamic segment in React Router.",
      code: false,
    },
  },
  {
    id: 47,
    topic: "React",
    question: "What does React Suspense enable?",
    code: false,
    language: false,
    options: [
      { text: "Automatic error handling", code: false },
      { text: "Optimized CSS loading", code: false },
      { text: "Component lazy loading and fallback UI", code: false },
      { text: "Server-side data fetching", code: false },
    ],
    answer: "Component lazy loading and fallback UI",
    explanation: {
      text: "React Suspense lets you wait for components to load (e.g. via `lazy`) and show a fallback UI meanwhile.",
      code: false,
    },
  },
  {
    id: 48,
    topic: "React",
    question:
      "Which method is used to fetch data in a React component before rendering (on server side)?",
    code: false,
    language: false,
    options: [
      { text: "useEffect", code: false },
      { text: "componentDidMount", code: false },
      { text: "getServerSideProps", code: false },
      { text: "React Query", code: false },
    ],
    answer: "getServerSideProps",
    explanation: {
      text: "getServerSideProps is a Next.js method that fetches data server-side before the component is rendered.",
      code: false,
    },
  },
  {
    id: 49,
    topic: "React",
    question:
      "Which testing library is commonly used to test React components?",
    code: false,
    language: false,
    options: [
      { text: "Jest", code: false },
      { text: "Mocha", code: false },
      { text: "React Testing Library", code: false },
      { text: "Enzyme", code: false },
    ],
    answer: "React Testing Library",
    explanation: {
      text: "React Testing Library encourages testing components in a way that resembles user interaction, focusing on behavior over implementation.",
      code: false,
    },
  },
  {
    id: 50,
    topic: "React",
    question: "What is a thunk in Redux?",
    code: false,
    language: false,
    options: [
      { text: "A way to throttle events", code: false },
      { text: "A middleware to handle asynchronous logic", code: false },
      { text: "A hook for managing state", code: false },
      { text: "A component factory function", code: false },
    ],
    answer: "A middleware to handle asynchronous logic",
    explanation: {
      text: "Redux Thunk allows writing functions that return another function (instead of actions), useful for async operations like API calls.",
      code: false,
    },
  },
  {
    id: 51,
    topic: "React",
    question:
      "Which React feature can you use with `React.lazy()` to dynamically load a component?",
    code: false,
    language: false,
    options: [
      { text: "Error Boundary", code: false },
      { text: "Suspense", code: false },
      { text: "StrictMode", code: false },
      { text: "useMemo", code: false },
    ],
    answer: "Suspense",
    explanation: {
      text: "`React.lazy()` lets you load components dynamically, and Suspense provides a fallback UI while loading.",
      code: false,
    },
  },
  {
    id: 52,
    topic: "React",
    question:
      "Which hook can you use to perform data fetching and caching in React?",
    code: false,
    language: false,
    options: [
      { text: "useCallback", code: false },
      { text: "useRef", code: false },
      { text: "useMemo", code: false },
      { text: "useSWR", code: false },
    ],
    answer: "useSWR",
    explanation: {
      text: "useSWR is a React hook library for data fetching, caching, and revalidation. It's commonly used with REST APIs.",
      code: false,
    },
  },

  // REACT — MISCELLANEOUS (IDs 53–55)

  {
    id: 53,
    topic: "React",
    question: "What is the virtual DOM in React?",
    code: false,
    language: false,
    options: [
      { text: "A direct representation of the HTML DOM", code: false },
      {
        text: "An in-memory representation of the real DOM used for efficient updates",
        code: false,
      },
      { text: "A browser API for animations", code: false },
      { text: "A feature only used in server-side rendering", code: false },
    ],
    answer:
      "An in-memory representation of the real DOM used for efficient updates",
    explanation: {
      text: "React creates a virtual DOM to track changes and update the real DOM efficiently by applying diffs instead of full re-renders.",
      code: false,
    },
  },
  {
    id: 54,
    topic: "React",
    question: "What is reconciliation in React?",
    code: false,
    language: false,
    options: [
      { text: "React's way of resolving state conflicts", code: false },
      {
        text: "The process of comparing the old and new virtual DOM trees to apply updates",
        code: false,
      },
      { text: "A lifecycle hook for cleaning up memory", code: false },
      { text: "An API to fetch data on the server", code: false },
    ],
    answer:
      "The process of comparing the old and new virtual DOM trees to apply updates",
    explanation: {
      text: "Reconciliation is the diffing process React uses to update only the parts of the DOM that changed — improving performance.",
      code: false,
    },
  },
  {
    id: 55,
    topic: "React",
    question: "What is React Fiber?",
    code: false,
    language: false,
    options: [
      { text: "A state management library for React", code: false },
      { text: "The old rendering engine of React", code: false },
      {
        text: "The new reconciliation engine in React that supports incremental rendering",
        code: false,
      },
      { text: "A CSS-in-JS library", code: false },
    ],
    answer:
      "The new reconciliation engine in React that supports incremental rendering",
    explanation: {
      text: "React Fiber is a complete rewrite of React’s core that enables asynchronous rendering and better scheduling of work.",
      code: false,
    },
  },
];
