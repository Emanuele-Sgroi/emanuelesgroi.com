/**
 * NOTE: All question sets here (and their Q&A pairs) were generated by AI
 * to help with knowledge retention across a variety of technical topics.
 *
 * This File Contains the questions used in Dev Quiz.
 * It holds arrays of question objects, each representing a specific technical area.
 *
 * Each question object has the following structure:
 * - `id`: A unique identifier for the question.
 * - `topic`: The subject or category of the question (e.g., React, JavaScript, Node.js).
 * - `question`: The text of the question being asked.
 * - `language`: (Optional) A string indicating the programming language for code-related questions.
 * - `code`: (Optional) A boolean indicating if the question involves code.
 * - `options`: An array of possible answers, each with a `text` property and an optional `code` property.
 * - `answer`: The correct answer for the question.
 * - `explanation`: An explanation of why the answer is correct, with optional code examples.
 *
 * Topic covered in this file:
 * - C# (Language features, OOP, LINQ, async/await, collections, modern features)
 */

// C# QUESTIONS
export const csharpQuestions = [
  // 1-5: C# BASICS
  {
    id: 1,
    topic: "C#",
    question: "Which of the following is a value type in C#?",
    code: false,
    language: false,
    options: [
      { text: "string", code: false },
      { text: "class", code: false },
      { text: "int", code: false },
      { text: "object", code: false },
    ],
    answer: "int",
    explanation: {
      text: "In C#, int is a value type (struct). String and object are reference types, and 'class' is a keyword for defining reference types.",
      code: false,
    },
  },
  {
    id: 2,
    topic: "C#",
    question: "What does the 'var' keyword do in C#?",
    code: false,
    language: false,
    options: [
      { text: "Declares a variable with dynamic typing", code: false },
      {
        text: "Declares a variable with implicit typing determined at compile time",
        code: false,
      },
      { text: "Creates a variable-length array", code: false },
      { text: "Defines a variant data type", code: false },
    ],
    answer:
      "Declares a variable with implicit typing determined at compile time",
    explanation: {
      text: "The 'var' keyword allows the compiler to infer the type based on the initialization expression. It's still strongly typed, just implicitly.",
      code: false,
    },
  },
  {
    id: 3,
    topic: "C#",
    question: "What is the correct way to declare a nullable integer in C#?",
    code: false,
    language: false,
    options: [
      { text: "int? myNumber = null;", code: false },
      { text: "nullable int myNumber = null;", code: false },
      { text: "int myNumber = nullable;", code: false },
      { text: "Nullable<int> myNumber = null;", code: false },
    ],
    answer: "int? myNumber = null;",
    explanation: {
      text: "The '?' suffix is shorthand for Nullable<T>. Both 'int?' and 'Nullable<int>' are valid, but 'int?' is the preferred syntax.",
      code: false,
    },
  },
  {
    id: 4,
    topic: "C#",
    question:
      "Which of the following correctly demonstrates string interpolation in C#?",
    code: false,
    language: false,
    options: [
      { text: '"Hello " + name + "!"', code: false },
      { text: '$"Hello {name}!"', code: false },
      { text: '"Hello {0}!".Format(name)', code: false },
      { text: '@"Hello {name}!"', code: false },
    ],
    answer: '$"Hello {name}!"',
    explanation: {
      text: "String interpolation uses the $ prefix before the string literal and expressions inside curly braces. The @ prefix is for verbatim strings.",
      code: false,
    },
  },
  {
    id: 5,
    topic: "C#",
    question: "What is the difference between 'const' and 'readonly' in C#?",
    code: false,
    language: false,
    options: [
      { text: "There is no difference", code: false },
      {
        text: "const can only be used with strings, readonly with any type",
        code: false,
      },
      {
        text: "const is compile-time constant, readonly can be set at runtime in constructor",
        code: false,
      },
      { text: "readonly is for static fields only", code: false },
    ],
    answer:
      "const is compile-time constant, readonly can be set at runtime in constructor",
    explanation: {
      text: "const values must be known at compile time and are implicitly static. readonly fields can be initialized at declaration or in the constructor.",
      code: false,
    },
  },

  // 6-12: OBJECT-ORIENTED PROGRAMMING
  {
    id: 6,
    topic: "C#",
    question:
      "Which access modifier makes a member accessible only within the same assembly?",
    code: false,
    language: false,
    options: [
      { text: "private", code: false },
      { text: "protected", code: false },
      { text: "internal", code: false },
      { text: "public", code: false },
    ],
    answer: "internal",
    explanation: {
      text: "The 'internal' access modifier restricts access to the current assembly. 'private' is class-only, 'protected' is class and derived classes, 'public' is unrestricted.",
      code: false,
    },
  },
  {
    id: 7,
    topic: "C#",
    question:
      "What is the main difference between an abstract class and an interface in C#?",
    code: false,
    language: false,
    options: [
      {
        text: "Interfaces can have implementations, abstract classes cannot",
        code: false,
      },
      {
        text: "Abstract classes can have constructors and fields, interfaces cannot",
        code: false,
      },
      {
        text: "You can inherit from multiple abstract classes but only one interface",
        code: false,
      },
      { text: "Abstract classes are faster than interfaces", code: false },
    ],
    answer:
      "Abstract classes can have constructors and fields, interfaces cannot",
    explanation: {
      text: "Abstract classes can have constructors, fields, and implementation. Interfaces (before C# 8) could only have method signatures. A class can implement multiple interfaces but inherit from only one class.",
      code: false,
    },
  },
  {
    id: 8,
    topic: "C#",
    question:
      "What is the correct syntax for a property with automatic backing field in C#?",
    code: false,
    language: false,
    options: [
      { text: "public int Age { get; set; }", code: false },
      { text: "public property int Age;", code: false },
      {
        text: "public int Age { get { return age; } set { age = value; } }",
        code: false,
      },
      { text: "public auto int Age;", code: false },
    ],
    answer: "public int Age { get; set; }",
    explanation: {
      text: "Auto-implemented properties use { get; set; } syntax. The compiler creates a private backing field automatically.",
      code: false,
    },
  },
  {
    id: 9,
    topic: "C#",
    question: "Which keyword is used to prevent a class from being inherited?",
    code: false,
    language: false,
    options: [
      { text: "static", code: false },
      { text: "sealed", code: false },
      { text: "final", code: false },
      { text: "abstract", code: false },
    ],
    answer: "sealed",
    explanation: {
      text: "The 'sealed' keyword prevents a class from being inherited. 'static' classes are also non-inheritable but serve a different purpose. 'final' is used in Java, not C#.",
      code: false,
    },
  },
  {
    id: 10,
    topic: "C#",
    question:
      "How do you properly override a virtual method in a derived class?",
    code: false,
    language: false,
    options: [
      { text: "public new void MethodName()", code: false },
      { text: "public override void MethodName()", code: false },
      { text: "public virtual void MethodName()", code: false },
      { text: "public base void MethodName()", code: false },
    ],
    answer: "public override void MethodName()",
    explanation: {
      text: "Use 'override' to override virtual methods. 'new' hides the base method instead of overriding. 'virtual' is used in the base class, not the derived class.",
      code: false,
    },
  },
  {
    id: 11,
    topic: "C#",
    question: "What does the 'base' keyword refer to in C#?",
    code: false,
    language: false,
    options: [
      { text: "The base data type of a variable", code: false },
      {
        text: "The parent class from which the current class inherits",
        code: false,
      },
      { text: "The root namespace of the application", code: false },
      { text: "The default value of a type", code: false },
    ],
    answer: "The parent class from which the current class inherits",
    explanation: {
      text: "The 'base' keyword is used to access members of the base (parent) class from within a derived class, such as base.MethodName() or base().",
      code: false,
    },
  },
  {
    id: 12,
    topic: "C#",
    question: "Which statement about C# constructors is correct?",
    code: false,
    language: false,
    options: [
      { text: "Constructors must have a return type", code: false },
      { text: "A class can only have one constructor", code: false },
      { text: "Constructors can be inherited", code: false },
      { text: "Constructors have the same name as the class", code: false },
    ],
    answer: "Constructors have the same name as the class",
    explanation: {
      text: "Constructors must have the same name as the class and no return type. Classes can have multiple constructors (overloading), and constructors are not inherited.",
      code: false,
    },
  },

  // 13-20: ADVANCED FEATURES
  {
    id: 13,
    topic: "C#",
    question: "What is the correct syntax for a generic method in C#?",
    code: false,
    language: false,
    options: [
      { text: "public <T> void MyMethod(T item)", code: false },
      { text: "public void MyMethod<T>(T item)", code: false },
      { text: "public void MyMethod(Generic<T> item)", code: false },
      { text: "public generic void MyMethod(T item)", code: false },
    ],
    answer: "public void MyMethod<T>(T item)",
    explanation: {
      text: "Generic type parameters are specified after the method name using angle brackets: MethodName<T>. This is different from Java which uses <T> before the return type.",
      code: false,
    },
  },
  {
    id: 14,
    topic: "C#",
    question: "What is a delegate in C#?",
    code: false,
    language: false,
    options: [
      { text: "A class that delegates work to other classes", code: false },
      {
        text: "A type that represents references to methods with a specific signature",
        code: false,
      },
      { text: "An interface implementation helper", code: false },
      { text: "A keyword for lazy initialization", code: false },
    ],
    answer:
      "A type that represents references to methods with a specific signature",
    explanation: {
      text: "A delegate is a type-safe function pointer that can hold references to both static and instance methods. Common built-in delegates include Action and Func.",
      code: false,
    },
  },
  {
    id: 15,
    topic: "C#",
    question:
      "Which built-in delegate type represents a method that returns void?",
    code: false,
    language: false,
    options: [
      { text: "Func<>", code: false },
      { text: "Action<>", code: false },
      { text: "Predicate<>", code: false },
      { text: "EventHandler<>", code: false },
    ],
    answer: "Action<>",
    explanation: {
      text: "Action delegates represent methods that return void. Func delegates return a value. Predicate returns bool, and EventHandler is for event handling.",
      code: false,
    },
  },
  {
    id: 16,
    topic: "C#",
    question: "What is an extension method in C#?",
    code: false,
    language: false,
    options: [
      { text: "A method that extends the execution time", code: false },
      {
        text: "A method that can be added to existing types without modifying them",
        code: false,
      },
      { text: "A method that extends the base class", code: false },
      { text: "A method available only in extended mode", code: false },
    ],
    answer:
      "A method that can be added to existing types without modifying them",
    explanation: {
      text: "Extension methods allow you to 'add' methods to existing types without modifying the original type. They're static methods called as if they were instance methods.",
      code: false,
    },
  },
  {
    id: 17,
    topic: "C#",
    question: "How do you define an extension method?",
    code: false,
    language: false,
    options: [
      { text: "public void MyMethod(this string str)", code: false },
      { text: "public static void MyMethod(this string str)", code: false },
      { text: "public extension void MyMethod(string str)", code: false },
      { text: "public static extension MyMethod(string str)", code: false },
    ],
    answer: "public static void MyMethod(this string str)",
    explanation: {
      text: "Extension methods must be static methods in a static class, with 'this' before the first parameter to indicate which type is being extended.",
      code: false,
    },
  },
  {
    id: 18,
    topic: "C#",
    question: "What are attributes in C# used for?",
    code: false,
    language: false,
    options: [
      { text: "To define variable types", code: false },
      { text: "To add metadata to code elements", code: false },
      { text: "To create class properties", code: false },
      { text: "To handle exceptions", code: false },
    ],
    answer: "To add metadata to code elements",
    explanation: {
      text: "Attributes provide a way to add declarative information (metadata) to code elements like classes, methods, properties. Examples include [Obsolete], [Serializable].",
      code: false,
    },
  },
  {
    id: 19,
    topic: "C#",
    question: "What is the purpose of the 'yield' keyword in C#?",
    code: false,
    language: false,
    options: [
      { text: "To pause thread execution", code: false },
      { text: "To return multiple values from a method", code: false },
      {
        text: "To create an iterator without storing all values in memory",
        code: false,
      },
      { text: "To yield CPU time to other processes", code: false },
    ],
    answer: "To create an iterator without storing all values in memory",
    explanation: {
      text: "The 'yield return' statement returns values one at a time from an iterator method, allowing lazy evaluation without creating a collection in memory.",
      code: false,
    },
  },
  {
    id: 20,
    topic: "C#",
    question: "What is the output of this code?",
    code: `int[] numbers = { 1, 2, 3 };
var result = numbers.Select(x => x * 2);
Console.WriteLine(result.GetType().Name);`,
    language: "csharp",
    options: [
      { text: "Int32[]", code: false },
      { text: "List", code: false },
      { text: "WhereSelectArrayIterator`2", code: false },
      { text: "IEnumerable", code: false },
    ],
    answer: "WhereSelectArrayIterator`2",
    explanation: {
      text: "LINQ methods like Select return iterator types (not arrays or lists). The actual type name includes implementation details. To get an array, you'd need .ToArray().",
      code: false,
    },
  },

  // 21-26: LINQ
  {
    id: 21,
    topic: "C#",
    question: "What does LINQ stand for?",
    code: false,
    language: false,
    options: [
      { text: "Linear Integrated Query", code: false },
      { text: "Language Integrated Query", code: false },
      { text: "Linked Internal Query", code: false },
      { text: "Language Independent Query", code: false },
    ],
    answer: "Language Integrated Query",
    explanation: {
      text: "LINQ (Language Integrated Query) provides a consistent way to query various data sources using C# syntax.",
      code: false,
    },
  },
  {
    id: 22,
    topic: "C#",
    question:
      "Which LINQ method would you use to filter a collection based on a condition?",
    code: false,
    language: false,
    options: [
      { text: "Select", code: false },
      { text: "Where", code: false },
      { text: "OrderBy", code: false },
      { text: "GroupBy", code: false },
    ],
    answer: "Where",
    explanation: {
      text: "The Where method filters elements based on a predicate. Select is for projection/transformation, OrderBy for sorting, and GroupBy for grouping.",
      code: false,
    },
  },
  {
    id: 23,
    topic: "C#",
    question: "What is deferred execution in LINQ?",
    code: false,
    language: false,
    options: [
      { text: "Queries that run after a delay", code: false },
      { text: "Queries that execute immediately when defined", code: false },
      {
        text: "Queries that execute only when the results are enumerated",
        code: false,
      },
      { text: "Queries that never execute", code: false },
    ],
    answer: "Queries that execute only when the results are enumerated",
    explanation: {
      text: "LINQ queries are not executed when defined but when iterated (foreach, ToList(), etc.). This allows for query composition and optimization.",
      code: false,
    },
  },
  {
    id: 24,
    topic: "C#",
    question: "Which LINQ method forces immediate execution?",
    code: false,
    language: false,
    options: [
      { text: "Where()", code: false },
      { text: "Select()", code: false },
      { text: "ToList()", code: false },
      { text: "OrderBy()", code: false },
    ],
    answer: "ToList()",
    explanation: {
      text: "ToList(), ToArray(), Count(), and other methods that return a concrete result force immediate query execution.",
      code: false,
    },
  },
  {
    id: 25,
    topic: "C#",
    question: "What is the equivalent method syntax for this query syntax?",
    code: `var result = from n in numbers
             where n > 5
             select n * 2;`,
    language: "csharp",
    options: [
      { text: "numbers.Where(n => n > 5).Select(n => n * 2)", code: false },
      { text: "numbers.Select(n => n * 2).Where(n => n > 5)", code: false },
      { text: "numbers.Where(n => n > 5 && n * 2)", code: false },
      { text: "numbers.Select(n => n > 5 ? n * 2 : n)", code: false },
    ],
    answer: "numbers.Where(n => n > 5).Select(n => n * 2)",
    explanation: {
      text: "In method syntax, operations are chained in order: first filter with Where, then transform with Select.",
      code: false,
    },
  },
  {
    id: 26,
    topic: "C#",
    question: "What does the 'let' keyword do in LINQ query syntax?",
    code: false,
    language: false,
    options: [
      { text: "Declares a variable type", code: false },
      {
        text: "Creates an intermediate variable within the query",
        code: false,
      },
      { text: "Allows modification of source data", code: false },
      { text: "Defines a lambda expression", code: false },
    ],
    answer: "Creates an intermediate variable within the query",
    explanation: {
      text: "The 'let' keyword introduces a new range variable to store intermediate results within a LINQ query expression.",
      code: false,
    },
  },

  // 27-32: ASYNC/AWAIT
  {
    id: 27,
    topic: "C#",
    question:
      "What is the return type of an async method that doesn't return a value?",
    code: false,
    language: false,
    options: [
      { text: "void", code: false },
      { text: "Task", code: false },
      { text: "async", code: false },
      { text: "ValueTask", code: false },
    ],
    answer: "Task",
    explanation: {
      text: "Async methods should return Task (or Task<T> if returning a value). Async void should only be used for event handlers.",
      code: false,
    },
  },
  {
    id: 28,
    topic: "C#",
    question: "What does the 'await' keyword do?",
    code: false,
    language: false,
    options: [
      { text: "Blocks the thread until the task completes", code: false },
      { text: "Creates a new thread for the operation", code: false },
      {
        text: "Suspends the method execution until the awaited task completes",
        code: false,
      },
      { text: "Makes the method run synchronously", code: false },
    ],
    answer: "Suspends the method execution until the awaited task completes",
    explanation: {
      text: "await doesn't block the thread; it returns control to the caller and resumes when the task completes. The thread can do other work meanwhile.",
      code: false,
    },
  },
  {
    id: 29,
    topic: "C#",
    question: "When should you use ConfigureAwait(false)?",
    code: false,
    language: false,
    options: [
      { text: "Always in UI applications", code: false },
      { text: "Never, it's deprecated", code: false },
      {
        text: "In library code where you don't need to return to the original context",
        code: false,
      },
      { text: "Only in console applications", code: false },
    ],
    answer:
      "In library code where you don't need to return to the original context",
    explanation: {
      text: "ConfigureAwait(false) prevents capturing the synchronization context, improving performance in library code where you don't need to return to the original context (like UI thread).",
      code: false,
    },
  },
  {
    id: 30,
    topic: "C#",
    question: "What's wrong with this async code?",
    code: `public async void GetDataAsync()
{
    var data = await FetchDataAsync();
    ProcessData(data);
}`,
    language: "csharp",
    options: [
      { text: "Nothing, it's correct", code: false },
      {
        text: "async void should be async Task except for event handlers",
        code: false,
      },
      { text: "You can't use await in a void method", code: false },
      { text: "ProcessData should also be async", code: false },
    ],
    answer: "async void should be async Task except for event handlers",
    explanation: {
      text: "async void methods can't be awaited and make exception handling difficult. Use async Task instead, except for event handlers where void is required.",
      code: false,
    },
  },
  {
    id: 31,
    topic: "C#",
    question:
      "What is the difference between Task.Run and Task.Factory.StartNew?",
    code: false,
    language: false,
    options: [
      { text: "No difference, Task.Run is just shorter", code: false },
      {
        text: "Task.Run is optimized for common scenarios and safer defaults",
        code: false,
      },
      { text: "Task.Factory.StartNew doesn't support async", code: false },
      { text: "Task.Run only works with void methods", code: false },
    ],
    answer: "Task.Run is optimized for common scenarios and safer defaults",
    explanation: {
      text: "Task.Run uses safer defaults (DenyChildAttach, uses thread pool). Task.Factory.StartNew offers more options but requires careful configuration.",
      code: false,
    },
  },
  {
    id: 32,
    topic: "C#",
    question: "How do you handle multiple async operations concurrently?",
    code: false,
    language: false,
    options: [
      { text: "await task1; await task2; await task3;", code: false },
      { text: "await Task.WhenAll(task1, task2, task3);", code: false },
      { text: "task1.Wait(); task2.Wait(); task3.Wait();", code: false },
      { text: "Parallel.ForEach with async lambda", code: false },
    ],
    answer: "await Task.WhenAll(task1, task2, task3);",
    explanation: {
      text: "Task.WhenAll runs multiple tasks concurrently and waits for all to complete. Sequential awaits would run them one after another.",
      code: false,
    },
  },

  // 33-37: COLLECTIONS
  {
    id: 33,
    topic: "C#",
    question: "What's the main difference between List<T> and Array in C#?",
    code: false,
    language: false,
    options: [
      { text: "Arrays are faster than Lists", code: false },
      { text: "Lists have dynamic size, arrays have fixed size", code: false },
      { text: "Arrays can only store primitive types", code: false },
      {
        text: "Lists are value types, arrays are reference types",
        code: false,
      },
    ],
    answer: "Lists have dynamic size, arrays have fixed size",
    explanation: {
      text: "Arrays have a fixed size once created. List<T> can grow or shrink dynamically. Both are reference types and can store any type.",
      code: false,
    },
  },
  {
    id: 34,
    topic: "C#",
    question:
      "Which collection would you use for unique items with fast lookups?",
    code: false,
    language: false,
    options: [
      { text: "List<T>", code: false },
      { text: "Dictionary<TKey, TValue>", code: false },
      { text: "HashSet<T>", code: false },
      { text: "Queue<T>", code: false },
    ],
    answer: "HashSet<T>",
    explanation: {
      text: "HashSet<T> stores unique items and provides O(1) lookup performance. Dictionary is for key-value pairs, List allows duplicates.",
      code: false,
    },
  },
  {
    id: 35,
    topic: "C#",
    question: "What's the difference between IEnumerable<T> and IQueryable<T>?",
    code: false,
    language: false,
    options: [
      { text: "No difference, they're aliases", code: false },
      { text: "IQueryable<T> is for in-memory collections only", code: false },
      {
        text: "IQueryable<T> supports expression trees for query providers like EF",
        code: false,
      },
      { text: "IEnumerable<T> is faster than IQueryable<T>", code: false },
    ],
    answer:
      "IQueryable<T> supports expression trees for query providers like EF",
    explanation: {
      text: "IQueryable<T> extends IEnumerable<T> with expression tree support, allowing query providers (like Entity Framework) to translate queries to SQL.",
      code: false,
    },
  },
  {
    id: 36,
    topic: "C#",
    question: "Which collection implements FIFO (First-In-First-Out)?",
    code: false,
    language: false,
    options: [
      { text: "Stack<T>", code: false },
      { text: "Queue<T>", code: false },
      { text: "List<T>", code: false },
      { text: "LinkedList<T>", code: false },
    ],
    answer: "Queue<T>",
    explanation: {
      text: "Queue<T> implements FIFO with Enqueue (add) and Dequeue (remove) operations. Stack<T> implements LIFO (Last-In-First-Out).",
      code: false,
    },
  },
  {
    id: 37,
    topic: "C#",
    question:
      "What happens when you try to add a duplicate key to a Dictionary<TKey, TValue>?",
    code: false,
    language: false,
    options: [
      { text: "The value is updated silently", code: false },
      { text: "ArgumentException is thrown", code: false },
      { text: "The duplicate is ignored", code: false },
      { text: "A new entry is created with the same key", code: false },
    ],
    answer: "ArgumentException is thrown",
    explanation: {
      text: "Dictionary doesn't allow duplicate keys. Use indexer (dict[key] = value) to update existing values or TryAdd to avoid exceptions.",
      code: false,
    },
  },

  // 38-42: ERROR HANDLING & BEST PRACTICES
  {
    id: 38,
    topic: "C#",
    question:
      "What is the correct way to use the 'using' statement for disposable resources?",
    code: false,
    language: false,
    options: [
      { text: "using System.IO;", code: false },
      { text: "using (var file = new FileStream(...)) { }", code: false },
      { text: "using var file = new FileStream(...);", code: false },
      { text: "Both B and C are correct", code: false },
    ],
    answer: "Both B and C are correct",
    explanation: {
      text: "Traditional using with braces disposes at the closing brace. C# 8's using declaration disposes at the end of the enclosing scope. Both ensure disposal.",
      code: false,
    },
  },
  {
    id: 39,
    topic: "C#",
    question: "Which exception should you throw for invalid method arguments?",
    code: false,
    language: false,
    options: [
      { text: "Exception", code: false },
      { text: "InvalidOperationException", code: false },
      { text: "ArgumentException", code: false },
      { text: "SystemException", code: false },
    ],
    answer: "ArgumentException",
    explanation: {
      text: "ArgumentException (or its derived classes like ArgumentNullException, ArgumentOutOfRangeException) should be used for invalid arguments. InvalidOperationException is for invalid object state.",
      code: false,
    },
  },
  {
    id: 40,
    topic: "C#",
    question: "What's the best practice for handling null values in modern C#?",
    code: false,
    language: false,
    options: [
      { text: "Always check with if (obj == null)", code: false },
      {
        text: "Use nullable reference types and null-conditional operators",
        code: false,
      },
      { text: "Throw exceptions for any null value", code: false },
      { text: "Use dynamic typing to avoid null checks", code: false },
    ],
    answer: "Use nullable reference types and null-conditional operators",
    explanation: {
      text: "Modern C# provides nullable reference types (C# 8+) for compile-time null safety and operators like ?. and ?? for concise null handling.",
      code: false,
    },
  },
  {
    id: 41,
    topic: "C#",
    question: "What does the null-conditional operator (?.) do?",
    code: false,
    language: false,
    options: [
      { text: "Throws exception if null", code: false },
      { text: "Converts null to empty string", code: false },
      {
        text: "Returns null if the object is null, otherwise accesses the member",
        code: false,
      },
      { text: "Assigns a default value if null", code: false },
    ],
    answer: "Returns null if the object is null, otherwise accesses the member",
    explanation: {
      text: "The ?. operator short-circuits and returns null if the left side is null, preventing NullReferenceException. Example: person?.Name returns null if person is null.",
      code: false,
    },
  },
  {
    id: 42,
    topic: "C#",
    question:
      "What is the purpose of the 'finally' block in exception handling?",
    code: false,
    language: false,
    options: [
      { text: "To catch all exceptions", code: false },
      { text: "To re-throw exceptions", code: false },
      {
        text: "To execute code regardless of whether an exception occurred",
        code: false,
      },
      { text: "To handle only specific exception types", code: false },
    ],
    answer: "To execute code regardless of whether an exception occurred",
    explanation: {
      text: "The finally block always executes, whether an exception was thrown or not, making it ideal for cleanup code like closing connections or releasing resources.",
      code: false,
    },
  },

  // 43-45: MODERN C# FEATURES
  {
    id: 43,
    topic: "C#",
    question: "What is pattern matching in C#?",
    code: false,
    language: false,
    options: [
      { text: "A way to match regular expressions", code: false },
      {
        text: "A feature for testing expressions against patterns and extracting values",
        code: false,
      },
      { text: "A design pattern for object creation", code: false },
      { text: "A string comparison technique", code: false },
    ],
    answer:
      "A feature for testing expressions against patterns and extracting values",
    explanation: {
      text: "Pattern matching allows you to test values against patterns, extract values, and make decisions based on the shape of data. Introduced in C# 7 and enhanced in later versions.",
      code: false,
    },
  },
  {
    id: 44,
    topic: "C#",
    question: "What is a record type in C#?",
    code: false,
    language: false,
    options: [
      { text: "A type for audio recording", code: false },
      {
        text: "A reference type with value-based equality and immutability features",
        code: false,
      },
      { text: "A database record representation", code: false },
      { text: "A logging mechanism", code: false },
    ],
    answer:
      "A reference type with value-based equality and immutability features",
    explanation: {
      text: "Records (C# 9+) are reference types that provide value-based equality, immutability support, and concise syntax for data-centric types.",
      code: false,
    },
  },
  {
    id: 45,
    topic: "C#",
    question: "What is the syntax for a switch expression in modern C#?",
    code: `var result = dayOfWeek switch
{
    1 => "Monday",
    2 => "Tuesday",
    _ => "Other day"
};`,
    language: "csharp",
    options: [
      { text: "This is incorrect syntax", code: false },
      {
        text: "This is a switch expression returning different values based on patterns",
        code: false,
      },
      { text: "This is a regular switch statement", code: false },
      { text: "This requires a break statement", code: false },
    ],
    answer:
      "This is a switch expression returning different values based on patterns",
    explanation: {
      text: "Switch expressions (C# 8+) provide a concise way to return values based on patterns. The _ is the discard pattern for default cases.",
      code: false,
    },
  },
];
